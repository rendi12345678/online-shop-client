{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  scheduleOnNextTick: null,\n  scheduleImmediate: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  scheduleOnNextTick: function () {\n    return scheduleOnNextTick;\n  },\n  scheduleImmediate: function () {\n    return scheduleImmediate;\n  }\n});\nconst scheduleOnNextTick = cb => {\n  // We use Promise.resolve().then() here so that the operation is scheduled at\n  // the end of the promise job queue, we then add it to the next process tick\n  // to ensure it's evaluated afterwards.\n  //\n  // This was inspired by the implementation of the DataLoader interface: https://github.com/graphql/dataloader/blob/d336bd15282664e0be4b4a657cb796f09bafbc6b/src/index.js#L213-L255\n  //\n  Promise.resolve().then(() => {\n    process.nextTick(cb);\n  });\n};\nconst scheduleImmediate = cb => {\n  if (process.env.NEXT_RUNTIME === \"edge\") {\n    setTimeout(cb, 0);\n  } else {\n    setImmediate(cb);\n  }\n};","map":{"version":3,"names":["scheduleOnNextTick","scheduleImmediate","cb","Promise","resolve","then","process","nextTick","env","NEXT_RUNTIME","setTimeout","setImmediate"],"sources":["../../src/lib/scheduler.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;;;EASaA,kBAAkB,WAAAA,CAAA;WAAlBA,kBAAA;;EAkBAC,iBAAiB,WAAAA,CAAA;WAAjBA,iBAAA;;;AAlBN,MAAMD,kBAAA,GAAgCE,EAAA;EAC3C;EACA;EACA;EACA;EACA;EACA;EACAC,OAAA,CAAQC,OAAO,GAAGC,IAAI,CAAC;IACrBC,OAAA,CAAQC,QAAQ,CAACL,EAAA;EACnB;AACF;AAQO,MAAMD,iBAAA,GAA+BC,EAAA;EAC1C,IAAII,OAAA,CAAQE,GAAG,CAACC,YAAY,KAAK,QAAQ;IACvCC,UAAA,CAAWR,EAAA,EAAI;EACjB,OAAO;IACLS,YAAA,CAAaT,EAAA;EACf;AACF"},"metadata":{},"sourceType":"script","externalDependencies":[]}