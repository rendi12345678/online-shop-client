{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  isBlockedPage: null,\n  cleanAmpPath: null,\n  debounce: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  isBlockedPage: function () {\n    return isBlockedPage;\n  },\n  cleanAmpPath: function () {\n    return cleanAmpPath;\n  },\n  debounce: function () {\n    return debounce;\n  }\n});\nconst _constants = require(\"../shared/lib/constants\");\nfunction isBlockedPage(page) {\n  return _constants.BLOCKED_PAGES.includes(page);\n}\nfunction cleanAmpPath(pathname) {\n  if (pathname.match(/\\?amp=(y|yes|true|1)/)) {\n    pathname = pathname.replace(/\\?amp=(y|yes|true|1)&?/, \"?\");\n  }\n  if (pathname.match(/&amp=(y|yes|true|1)/)) {\n    pathname = pathname.replace(/&amp=(y|yes|true|1)/, \"\");\n  }\n  pathname = pathname.replace(/\\?$/, \"\");\n  return pathname;\n}\nfunction debounce(fn, ms, maxWait = Infinity) {\n  let timeoutId;\n  // The time the debouncing function was first called during this debounce queue.\n  let startTime = 0;\n  // The time the debouncing function was last called.\n  let lastCall = 0;\n  // The arguments and this context of the last call to the debouncing function.\n  let args, context;\n  // A helper used to that either invokes the debounced function, or\n  // reschedules the timer if a more recent call was made.\n  function run() {\n    const now = Date.now();\n    const diff = lastCall + ms - now;\n    // If the diff is non-positive, then we've waited at least `ms`\n    // milliseconds since the last call. Or if we've waited for longer than the\n    // max wait time, we must call the debounced function.\n    if (diff <= 0 || startTime + maxWait >= now) {\n      // It's important to clear the timeout id before invoking the debounced\n      // function, in case the function calls the debouncing function again.\n      timeoutId = undefined;\n      fn.apply(context, args);\n    } else {\n      // Else, a new call was made after the original timer was scheduled. We\n      // didn't clear the timeout (doing so is very slow), so now we need to\n      // reschedule the timer for the time difference.\n      timeoutId = setTimeout(run, diff);\n    }\n  }\n  return function (...passedArgs) {\n    // The arguments and this context of the most recent call are saved so the\n    // debounced function can be invoked with them later.\n    args = passedArgs;\n    context = this;\n    // Instead of constantly clearing and scheduling a timer, we record the\n    // time of the last call. If a second call comes in before the timer fires,\n    // then we'll reschedule in the run function. Doing this is considerably\n    // faster.\n    lastCall = Date.now();\n    // Only schedule a new timer if we're not currently waiting.\n    if (timeoutId === undefined) {\n      startTime = lastCall;\n      timeoutId = setTimeout(run, ms);\n    }\n  };\n}","map":{"version":3,"names":["isBlockedPage","cleanAmpPath","debounce","page","_constants","BLOCKED_PAGES","includes","pathname","match","replace","fn","ms","maxWait","Infinity","timeoutId","startTime","lastCall","args","context","run","now","Date","diff","undefined","apply","setTimeout","passedArgs"],"sources":["../../src/server/utils.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;;;;EAEgBA,aAAa,WAAAA,CAAA;WAAbA,aAAA;;EAIAC,YAAY,WAAAA,CAAA;WAAZA,YAAA;;EAYAC,QAAQ,WAAAA,CAAA;WAARA,QAAA;;;2BAlBc;AAEvB,SAASF,cAAcG,IAAY;EACxC,OAAOC,UAAA,CAAAC,aAAa,CAACC,QAAQ,CAACH,IAAA;AAChC;AAEO,SAASF,aAAaM,QAAgB;EAC3C,IAAIA,QAAA,CAASC,KAAK,CAAC,yBAAyB;IAC1CD,QAAA,GAAWA,QAAA,CAASE,OAAO,CAAC,0BAA0B;EACxD;EACA,IAAIF,QAAA,CAASC,KAAK,CAAC,wBAAwB;IACzCD,QAAA,GAAWA,QAAA,CAASE,OAAO,CAAC,uBAAuB;EACrD;EACAF,QAAA,GAAWA,QAAA,CAASE,OAAO,CAAC,OAAO;EACnC,OAAOF,QAAA;AACT;AAGO,SAASL,SACdQ,EAAK,EACLC,EAAU,EACVC,OAAA,GAAUC,QAAQ;EAElB,IAAIC,SAAA;EAEJ;EACA,IAAIC,SAAA,GAAY;EAChB;EACA,IAAIC,QAAA,GAAW;EAEf;EACA,IAAIC,IAAA,EAAqBC,OAAA;EAEzB;EACA;EACA,SAASC,IAAA;IACP,MAAMC,GAAA,GAAMC,IAAA,CAAKD,GAAG;IACpB,MAAME,IAAA,GAAON,QAAA,GAAWL,EAAA,GAAKS,GAAA;IAE7B;IACA;IACA;IACA,IAAIE,IAAA,IAAQ,KAAKP,SAAA,GAAYH,OAAA,IAAWQ,GAAA,EAAK;MAC3C;MACA;MACAN,SAAA,GAAYS,SAAA;MACZb,EAAA,CAAGc,KAAK,CAACN,OAAA,EAASD,IAAA;IACpB,OAAO;MACL;MACA;MACA;MACAH,SAAA,GAAYW,UAAA,CAAWN,GAAA,EAAKG,IAAA;IAC9B;EACF;EAEA,OAAO,UAAmB,GAAGI,UAAyB;IACpD;IACA;IACAT,IAAA,GAAOS,UAAA;IACPR,OAAA,GAAU,IAAI;IAEd;IACA;IACA;IACA;IACAF,QAAA,GAAWK,IAAA,CAAKD,GAAG;IAEnB;IACA,IAAIN,SAAA,KAAcS,SAAA,EAAW;MAC3BR,SAAA,GAAYC,QAAA;MACZF,SAAA,GAAYW,UAAA,CAAWN,GAAA,EAAKR,EAAA;IAC9B;EACF;AACF"},"metadata":{},"sourceType":"script","externalDependencies":[]}