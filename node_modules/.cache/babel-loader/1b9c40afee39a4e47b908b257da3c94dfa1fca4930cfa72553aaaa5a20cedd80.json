{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  CacheHandler: null,\n  IncrementalCache: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  CacheHandler: function () {\n    return CacheHandler;\n  },\n  IncrementalCache: function () {\n    return IncrementalCache;\n  }\n});\nconst _fetchcache = /*#__PURE__*/_interop_require_default(require(\"./fetch-cache\"));\nconst _filesystemcache = /*#__PURE__*/_interop_require_default(require(\"./file-system-cache\"));\nconst _path = /*#__PURE__*/_interop_require_default(require(\"../../../shared/lib/isomorphic/path\"));\nconst _normalizepagepath = require(\"../../../shared/lib/page-path/normalize-page-path\");\nconst _constants = require(\"../../../lib/constants\");\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction toRoute(pathname) {\n  return pathname.replace(/\\/$/, \"\").replace(/\\/index$/, \"\") || \"/\";\n}\nclass CacheHandler {\n  // eslint-disable-next-line\n  constructor(_ctx) {}\n  async get(..._args) {\n    return {};\n  }\n  async set(..._args) {}\n  async revalidateTag(_tag) {}\n}\nclass IncrementalCache {\n  constructor({\n    fs,\n    dev,\n    appDir,\n    flushToDisk,\n    fetchCache,\n    minimalMode,\n    serverDistDir,\n    requestHeaders,\n    requestProtocol,\n    maxMemoryCacheSize,\n    getPrerenderManifest,\n    fetchCacheKeyPrefix,\n    CurCacheHandler,\n    allowedRevalidateHeaderKeys\n  }) {\n    var _this_prerenderManifest_preview, _this_prerenderManifest, _this_prerenderManifest_preview1, _this_prerenderManifest1;\n    this.locks = new Map();\n    this.unlocks = new Map();\n    const debug = !!process.env.NEXT_PRIVATE_DEBUG_CACHE;\n    if (!CurCacheHandler) {\n      if (fs && serverDistDir) {\n        if (debug) {\n          console.log(\"using filesystem cache handler\");\n        }\n        CurCacheHandler = _filesystemcache.default;\n      }\n      if (_fetchcache.default.isAvailable({\n        _requestHeaders: requestHeaders\n      }) && minimalMode && fetchCache) {\n        if (debug) {\n          console.log(\"using fetch cache handler\");\n        }\n        CurCacheHandler = _fetchcache.default;\n      }\n    } else if (debug) {\n      console.log(\"using custom cache handler\", CurCacheHandler.name);\n    }\n    if (process.env.__NEXT_TEST_MAX_ISR_CACHE) {\n      // Allow cache size to be overridden for testing purposes\n      maxMemoryCacheSize = parseInt(process.env.__NEXT_TEST_MAX_ISR_CACHE, 10);\n    }\n    this.dev = dev;\n    // this is a hack to avoid Webpack knowing this is equal to this.minimalMode\n    // because we replace this.minimalMode to true in production bundles.\n    const minimalModeKey = \"minimalMode\";\n    this[minimalModeKey] = minimalMode;\n    this.requestHeaders = requestHeaders;\n    this.requestProtocol = requestProtocol;\n    this.allowedRevalidateHeaderKeys = allowedRevalidateHeaderKeys;\n    this.prerenderManifest = getPrerenderManifest();\n    this.fetchCacheKeyPrefix = fetchCacheKeyPrefix;\n    let revalidatedTags = [];\n    if (requestHeaders[_constants.PRERENDER_REVALIDATE_HEADER] === ((_this_prerenderManifest = this.prerenderManifest) == null ? void 0 : (_this_prerenderManifest_preview = _this_prerenderManifest.preview) == null ? void 0 : _this_prerenderManifest_preview.previewModeId)) {\n      this.isOnDemandRevalidate = true;\n    }\n    if (minimalMode && typeof requestHeaders[_constants.NEXT_CACHE_REVALIDATED_TAGS_HEADER] === \"string\" && requestHeaders[_constants.NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER] === ((_this_prerenderManifest1 = this.prerenderManifest) == null ? void 0 : (_this_prerenderManifest_preview1 = _this_prerenderManifest1.preview) == null ? void 0 : _this_prerenderManifest_preview1.previewModeId)) {\n      revalidatedTags = requestHeaders[_constants.NEXT_CACHE_REVALIDATED_TAGS_HEADER].split(\",\");\n    }\n    if (CurCacheHandler) {\n      this.cacheHandler = new CurCacheHandler({\n        dev,\n        fs,\n        flushToDisk,\n        serverDistDir,\n        revalidatedTags,\n        maxMemoryCacheSize,\n        _appDir: !!appDir,\n        _requestHeaders: requestHeaders,\n        fetchCacheKeyPrefix\n      });\n    }\n  }\n  calculateRevalidate(pathname, fromTime, dev) {\n    // in development we don't have a prerender-manifest\n    // and default to always revalidating to allow easier debugging\n    if (dev) return new Date().getTime() - 1000;\n    // if an entry isn't present in routes we fallback to a default\n    // of revalidating after 1 second\n    const {\n      initialRevalidateSeconds\n    } = this.prerenderManifest.routes[toRoute(pathname)] || {\n      initialRevalidateSeconds: 1\n    };\n    const revalidateAfter = typeof initialRevalidateSeconds === \"number\" ? initialRevalidateSeconds * 1000 + fromTime : initialRevalidateSeconds;\n    return revalidateAfter;\n  }\n  _getPathname(pathname, fetchCache) {\n    return fetchCache ? pathname : (0, _normalizepagepath.normalizePagePath)(pathname);\n  }\n  async unlock(cacheKey) {\n    const unlock = this.unlocks.get(cacheKey);\n    if (unlock) {\n      unlock();\n      this.locks.delete(cacheKey);\n      this.unlocks.delete(cacheKey);\n    }\n  }\n  async lock(cacheKey) {\n    if (process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT && process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY && process.env.NEXT_RUNTIME !== \"edge\") {\n      const invokeIpcMethod = require(\"../server-ipc/request-utils\").invokeIpcMethod;\n      await invokeIpcMethod({\n        method: \"lock\",\n        ipcPort: process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT,\n        ipcKey: process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY,\n        args: [cacheKey]\n      });\n      return async () => {\n        await invokeIpcMethod({\n          method: \"unlock\",\n          ipcPort: process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT,\n          ipcKey: process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY,\n          args: [cacheKey]\n        });\n      };\n    }\n    let unlockNext = () => Promise.resolve();\n    const existingLock = this.locks.get(cacheKey);\n    if (existingLock) {\n      await existingLock;\n    } else {\n      const newLock = new Promise(resolve => {\n        unlockNext = async () => {\n          resolve();\n        };\n      });\n      this.locks.set(cacheKey, newLock);\n      this.unlocks.set(cacheKey, unlockNext);\n    }\n    return unlockNext;\n  }\n  async revalidateTag(tag) {\n    var _this_cacheHandler_revalidateTag, _this_cacheHandler;\n    if (process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT && process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY && process.env.NEXT_RUNTIME !== \"edge\") {\n      const invokeIpcMethod = require(\"../server-ipc/request-utils\").invokeIpcMethod;\n      return invokeIpcMethod({\n        method: \"revalidateTag\",\n        ipcPort: process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT,\n        ipcKey: process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY,\n        args: [...arguments]\n      });\n    }\n    return (_this_cacheHandler = this.cacheHandler) == null ? void 0 : (_this_cacheHandler_revalidateTag = _this_cacheHandler.revalidateTag) == null ? void 0 : _this_cacheHandler_revalidateTag.call(_this_cacheHandler, tag);\n  }\n  // x-ref: https://github.com/facebook/react/blob/2655c9354d8e1c54ba888444220f63e836925caa/packages/react/src/ReactFetch.js#L23\n  async fetchCacheKey(url, init = {}) {\n    // this should be bumped anytime a fix is made to cache entries\n    // that should bust the cache\n    const MAIN_KEY_PREFIX = \"v3\";\n    let cacheKey;\n    const bodyChunks = [];\n    const encoder = new TextEncoder();\n    const decoder = new TextDecoder();\n    if (init.body) {\n      // handle ReadableStream body\n      if (typeof init.body.getReader === \"function\") {\n        const readableBody = init.body;\n        const chunks = [];\n        try {\n          await readableBody.pipeTo(new WritableStream({\n            write(chunk) {\n              if (typeof chunk === \"string\") {\n                chunks.push(encoder.encode(chunk));\n                bodyChunks.push(chunk);\n              } else {\n                chunks.push(chunk);\n                bodyChunks.push(decoder.decode(chunk, {\n                  stream: true\n                }));\n              }\n            }\n          }));\n          // Flush the decoder.\n          bodyChunks.push(decoder.decode());\n          // Create a new buffer with all the chunks.\n          const length = chunks.reduce((total, arr) => total + arr.length, 0);\n          const arrayBuffer = new Uint8Array(length);\n          // Push each of the chunks into the new array buffer.\n          let offset = 0;\n          for (const chunk of chunks) {\n            arrayBuffer.set(chunk, offset);\n            offset += chunk.length;\n          }\n          init._ogBody = arrayBuffer;\n        } catch (err) {\n          console.error(\"Problem reading body\", err);\n        }\n      } else if (typeof init.body.keys === \"function\") {\n        const formData = init.body;\n        init._ogBody = init.body;\n        for (const key of new Set([...formData.keys()])) {\n          const values = formData.getAll(key);\n          bodyChunks.push(`${key}=${(await Promise.all(values.map(async val => {\n            if (typeof val === \"string\") {\n              return val;\n            } else {\n              return await val.text();\n            }\n          }))).join(\",\")}`);\n        }\n        // handle blob body\n      } else if (typeof init.body.arrayBuffer === \"function\") {\n        const blob = init.body;\n        const arrayBuffer = await blob.arrayBuffer();\n        bodyChunks.push(await blob.text());\n        init._ogBody = new Blob([arrayBuffer], {\n          type: blob.type\n        });\n      } else if (typeof init.body === \"string\") {\n        bodyChunks.push(init.body);\n        init._ogBody = init.body;\n      }\n    }\n    const cacheString = JSON.stringify([MAIN_KEY_PREFIX, this.fetchCacheKeyPrefix || \"\", url, init.method, typeof (init.headers || {}).keys === \"function\" ? Object.fromEntries(init.headers) : init.headers, init.mode, init.redirect, init.credentials, init.referrer, init.referrerPolicy, init.integrity, init.cache, bodyChunks]);\n    if (process.env.NEXT_RUNTIME === \"edge\") {\n      function bufferToHex(buffer) {\n        return Array.prototype.map.call(new Uint8Array(buffer), b => b.toString(16).padStart(2, \"0\")).join(\"\");\n      }\n      const buffer = encoder.encode(cacheString);\n      cacheKey = bufferToHex(await crypto.subtle.digest(\"SHA-256\", buffer));\n    } else {\n      const crypto1 = require(\"crypto\");\n      cacheKey = crypto1.createHash(\"sha256\").update(cacheString).digest(\"hex\");\n    }\n    return cacheKey;\n  }\n  // get data from cache if available\n  async get(cacheKey, ctx = {}) {\n    var _this_cacheHandler, _cacheData_value, _this_prerenderManifest_routes_toRoute;\n    if (process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT && process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY && process.env.NEXT_RUNTIME !== \"edge\") {\n      const invokeIpcMethod = require(\"../server-ipc/request-utils\").invokeIpcMethod;\n      return invokeIpcMethod({\n        method: \"get\",\n        ipcPort: process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT,\n        ipcKey: process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY,\n        args: [...arguments]\n      });\n    }\n    // we don't leverage the prerender cache in dev mode\n    // so that getStaticProps is always called for easier debugging\n    if (this.dev && (!ctx.fetchCache || this.requestHeaders[\"cache-control\"] === \"no-cache\")) {\n      return null;\n    }\n    cacheKey = this._getPathname(cacheKey, ctx.fetchCache);\n    let entry = null;\n    let revalidate = ctx.revalidate;\n    const cacheData = await ((_this_cacheHandler = this.cacheHandler) == null ? void 0 : _this_cacheHandler.get(cacheKey, ctx));\n    if ((cacheData == null ? void 0 : (_cacheData_value = cacheData.value) == null ? void 0 : _cacheData_value.kind) === \"FETCH\") {\n      const combinedTags = [...(ctx.tags || []), ...(ctx.softTags || [])];\n      // if a tag was revalidated we don't return stale data\n      if (combinedTags.some(tag => {\n        var _this_revalidatedTags;\n        return (_this_revalidatedTags = this.revalidatedTags) == null ? void 0 : _this_revalidatedTags.includes(tag);\n      })) {\n        return null;\n      }\n      revalidate = revalidate || cacheData.value.revalidate;\n      const age = Math.round((Date.now() - (cacheData.lastModified || 0)) / 1000);\n      const isStale = age > revalidate;\n      const data = cacheData.value.data;\n      return {\n        isStale: isStale,\n        value: {\n          kind: \"FETCH\",\n          data,\n          revalidate: revalidate\n        },\n        revalidateAfter: Date.now() + revalidate * 1000\n      };\n    }\n    const curRevalidate = (_this_prerenderManifest_routes_toRoute = this.prerenderManifest.routes[toRoute(cacheKey)]) == null ? void 0 : _this_prerenderManifest_routes_toRoute.initialRevalidateSeconds;\n    let isStale;\n    let revalidateAfter;\n    if ((cacheData == null ? void 0 : cacheData.lastModified) === -1) {\n      isStale = -1;\n      revalidateAfter = -1 * _constants.CACHE_ONE_YEAR;\n    } else {\n      revalidateAfter = this.calculateRevalidate(cacheKey, (cacheData == null ? void 0 : cacheData.lastModified) || Date.now(), this.dev && !ctx.fetchCache);\n      isStale = revalidateAfter !== false && revalidateAfter < Date.now() ? true : undefined;\n    }\n    if (cacheData) {\n      entry = {\n        isStale,\n        curRevalidate,\n        revalidateAfter,\n        value: cacheData.value\n      };\n    }\n    if (!cacheData && this.prerenderManifest.notFoundRoutes.includes(cacheKey)) {\n      // for the first hit after starting the server the cache\n      // may not have a way to save notFound: true so if\n      // the prerender-manifest marks this as notFound then we\n      // return that entry and trigger a cache set to give it a\n      // chance to update in-memory entries\n      entry = {\n        isStale,\n        value: null,\n        curRevalidate,\n        revalidateAfter\n      };\n      this.set(cacheKey, entry.value, ctx);\n    }\n    return entry;\n  }\n  // populate the incremental cache with new data\n  async set(pathname, data, ctx) {\n    if (process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT && process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY && process.env.NEXT_RUNTIME !== \"edge\") {\n      const invokeIpcMethod = require(\"../server-ipc/request-utils\").invokeIpcMethod;\n      return invokeIpcMethod({\n        method: \"set\",\n        ipcPort: process.env.__NEXT_INCREMENTAL_CACHE_IPC_PORT,\n        ipcKey: process.env.__NEXT_INCREMENTAL_CACHE_IPC_KEY,\n        args: [...arguments]\n      });\n    }\n    if (this.dev && !ctx.fetchCache) return;\n    // fetchCache has upper limit of 2MB per-entry currently\n    if (ctx.fetchCache && JSON.stringify(data).length > 2 * 1024 * 1024) {\n      if (this.dev) {\n        throw new Error(`fetch for over 2MB of data can not be cached`);\n      }\n      return;\n    }\n    pathname = this._getPathname(pathname, ctx.fetchCache);\n    try {\n      var _this_cacheHandler;\n      // we use the prerender manifest memory instance\n      // to store revalidate timings for calculating\n      // revalidateAfter values so we update this on set\n      if (typeof ctx.revalidate !== \"undefined\" && !ctx.fetchCache) {\n        this.prerenderManifest.routes[pathname] = {\n          dataRoute: _path.default.posix.join(\"/_next/data\", `${(0, _normalizepagepath.normalizePagePath)(pathname)}.json`),\n          srcRoute: null,\n          initialRevalidateSeconds: ctx.revalidate\n        };\n      }\n      await ((_this_cacheHandler = this.cacheHandler) == null ? void 0 : _this_cacheHandler.set(pathname, data, ctx));\n    } catch (error) {\n      console.warn(\"Failed to update prerender cache for\", pathname, error);\n    }\n  }\n}","map":{"version":3,"names":["CacheHandler","IncrementalCache","toRoute","pathname","replace","constructor","_ctx","get","_args","set","revalidateTag","_tag","fs","dev","appDir","flushToDisk","fetchCache","minimalMode","serverDistDir","requestHeaders","requestProtocol","maxMemoryCacheSize","getPrerenderManifest","fetchCacheKeyPrefix","CurCacheHandler","allowedRevalidateHeaderKeys","_this_prerenderManifest_preview","_this_prerenderManifest","_this_prerenderManifest_preview1","_this_prerenderManifest1","locks","Map","unlocks","debug","process","env","NEXT_PRIVATE_DEBUG_CACHE","console","log","_filesystemcache","default","_fetchcache","isAvailable","_requestHeaders","name","__NEXT_TEST_MAX_ISR_CACHE","parseInt","minimalModeKey","prerenderManifest","revalidatedTags","_constants","PRERENDER_REVALIDATE_HEADER","preview","previewModeId","isOnDemandRevalidate","NEXT_CACHE_REVALIDATED_TAGS_HEADER","NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER","split","cacheHandler","_appDir","calculateRevalidate","fromTime","Date","getTime","initialRevalidateSeconds","routes","revalidateAfter","_getPathname","_normalizepagepath","normalizePagePath","unlock","cacheKey","delete","lock","__NEXT_INCREMENTAL_CACHE_IPC_PORT","__NEXT_INCREMENTAL_CACHE_IPC_KEY","NEXT_RUNTIME","invokeIpcMethod","require","method","ipcPort","ipcKey","args","unlockNext","Promise","resolve","existingLock","newLock","tag","_this_cacheHandler_revalidateTag","_this_cacheHandler","arguments","call","fetchCacheKey","url","init","MAIN_KEY_PREFIX","bodyChunks","encoder","TextEncoder","decoder","TextDecoder","body","getReader","readableBody","chunks","pipeTo","WritableStream","write","chunk","push","encode","decode","stream","length","reduce","total","arr","arrayBuffer","Uint8Array","offset","_ogBody","err","error","keys","formData","key","Set","values","getAll","all","map","val","text","join","blob","Blob","type","cacheString","JSON","stringify","headers","Object","fromEntries","mode","redirect","credentials","referrer","referrerPolicy","integrity","cache","bufferToHex","buffer","Array","prototype","b","toString","padStart","crypto","subtle","digest","crypto1","createHash","update","ctx","_cacheData_value","_this_prerenderManifest_routes_toRoute","entry","revalidate","cacheData","value","kind","combinedTags","tags","softTags","some","_this_revalidatedTags","includes","age","Math","round","now","lastModified","isStale","data","curRevalidate","CACHE_ONE_YEAR","undefined","notFoundRoutes","Error","dataRoute","_path","posix","srcRoute","warn"],"sources":["../../../../src/server/lib/incremental-cache/index.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;;;EA0CaA,YAAY,WAAAA,CAAA;WAAZA,YAAA;;EAiBAC,gBAAgB,WAAAA,CAAA;WAAhBA,gBAAA;;;kEArDU;uEACK;4DACX;mCACiB;2BAO3B;;;;;;AAEP,SAASC,QAAQC,QAAgB;EAC/B,OAAOA,QAAA,CAASC,OAAO,CAAC,OAAO,IAAIA,OAAO,CAAC,YAAY,OAAO;AAChE;AAsBO,MAAMJ,YAAA;EACX;EACAK,YAAYC,IAAyB,EAAE,CAAC;EAExC,MAAaC,IACX,GAAGC,KAA0C,EACV;IACnC,OAAO,CAAC;EACV;EAEA,MAAaC,IACX,GAAGD,KAA0C,EAC9B,CAAC;EAElB,MAAaE,cAAcC,IAAY,EAAiB,CAAC;AAC3D;AAEO,MAAMV,gBAAA;EAcXI,YAAY;IACVO,EAAE;IACFC,GAAG;IACHC,MAAM;IACNC,WAAW;IACXC,UAAU;IACVC,WAAW;IACXC,aAAa;IACbC,cAAc;IACdC,eAAe;IACfC,kBAAkB;IAClBC,oBAAoB;IACpBC,mBAAmB;IACnBC,eAAe;IACfC;EAA2B,CAgB5B,EAAE;QAyCCC,+BAAA,EAAAC,uBAAA,EASEC,gCAAA,EAAAC,wBAAA;SAnFEC,KAAA,GAAQ,IAAIC,GAAA;SACZC,OAAA,GAAU,IAAID,GAAA;IAiCpB,MAAME,KAAA,GAAQ,CAAC,CAACC,OAAA,CAAQC,GAAG,CAACC,wBAAwB;IACpD,IAAI,CAACZ,eAAA,EAAiB;MACpB,IAAIZ,EAAA,IAAMM,aAAA,EAAe;QACvB,IAAIe,KAAA,EAAO;UACTI,OAAA,CAAQC,GAAG,CAAC;QACd;QACAd,eAAA,GAAkBe,gBAAA,CAAAC,OAAe;MACnC;MACA,IACEC,WAAA,CAAAD,OAAU,CAACE,WAAW,CAAC;QAAEC,eAAA,EAAiBxB;MAAe,MACzDF,WAAA,IACAD,UAAA,EACA;QACA,IAAIiB,KAAA,EAAO;UACTI,OAAA,CAAQC,GAAG,CAAC;QACd;QACAd,eAAA,GAAkBiB,WAAA,CAAAD,OAAU;MAC9B;IACF,OAAO,IAAIP,KAAA,EAAO;MAChBI,OAAA,CAAQC,GAAG,CAAC,8BAA8Bd,eAAA,CAAgBoB,IAAI;IAChE;IAEA,IAAIV,OAAA,CAAQC,GAAG,CAACU,yBAAyB,EAAE;MACzC;MACAxB,kBAAA,GAAqByB,QAAA,CAASZ,OAAA,CAAQC,GAAG,CAACU,yBAAyB,EAAE;IACvE;IACA,IAAI,CAAChC,GAAG,GAAGA,GAAA;IACX;IACA;IACA,MAAMkC,cAAA,GAAiB;IACvB,IAAI,CAACA,cAAA,CAAe,GAAG9B,WAAA;IACvB,IAAI,CAACE,cAAc,GAAGA,cAAA;IACtB,IAAI,CAACC,eAAe,GAAGA,eAAA;IACvB,IAAI,CAACK,2BAA2B,GAAGA,2BAAA;IACnC,IAAI,CAACuB,iBAAiB,GAAG1B,oBAAA;IACzB,IAAI,CAACC,mBAAmB,GAAGA,mBAAA;IAC3B,IAAI0B,eAAA,GAA4B,EAAE;IAElC,IACE9B,cAAc,CAAC+B,UAAA,CAAAC,2BAA2B,CAAC,OAC3CxB,uBAAA,OAAI,CAACqB,iBAAiB,sBAAtBtB,+BAAA,GAAAC,uBAAA,CAAwByB,OAAO,qBAA/B1B,+BAAA,CAAiC2B,aAAa,GAC9C;MACA,IAAI,CAACC,oBAAoB,GAAG;IAC9B;IAEA,IACErC,WAAA,IACA,OAAOE,cAAc,CAAC+B,UAAA,CAAAK,kCAAkC,CAAC,KAAK,YAC9DpC,cAAc,CAAC+B,UAAA,CAAAM,sCAAsC,CAAC,OACpD3B,wBAAA,OAAI,CAACmB,iBAAiB,sBAAtBpB,gCAAA,GAAAC,wBAAA,CAAwBuB,OAAO,qBAA/BxB,gCAAA,CAAiCyB,aAAa,GAChD;MACAJ,eAAA,GACE9B,cAAc,CAAC+B,UAAA,CAAAK,kCAAkC,CAAC,CAACE,KAAK,CAAC;IAC7D;IAEA,IAAIjC,eAAA,EAAiB;MACnB,IAAI,CAACkC,YAAY,GAAG,IAAIlC,eAAA,CAAgB;QACtCX,GAAA;QACAD,EAAA;QACAG,WAAA;QACAG,aAAA;QACA+B,eAAA;QACA5B,kBAAA;QACAsC,OAAA,EAAS,CAAC,CAAC7C,MAAA;QACX6B,eAAA,EAAiBxB,cAAA;QACjBI;MACF;IACF;EACF;EAEQqC,oBACNzD,QAAgB,EAChB0D,QAAgB,EAChBhD,GAAa,EACG;IAChB;IACA;IACA,IAAIA,GAAA,EAAK,OAAO,IAAIiD,IAAA,GAAOC,OAAO,KAAK;IAEvC;IACA;IACA,MAAM;MAAEC;IAAwB,CAAE,GAAG,IAAI,CAAChB,iBAAiB,CAACiB,MAAM,CAChE/D,OAAA,CAAQC,QAAA,EACT,IAAI;MACH6D,wBAAA,EAA0B;IAC5B;IACA,MAAME,eAAA,GACJ,OAAOF,wBAAA,KAA6B,WAChCA,wBAAA,GAA2B,OAAOH,QAAA,GAClCG,wBAAA;IAEN,OAAOE,eAAA;EACT;EAEAC,aAAahE,QAAgB,EAAEa,UAAoB,EAAE;IACnD,OAAOA,UAAA,GAAab,QAAA,GAAW,IAAAiE,kBAAA,CAAAC,iBAAiB,EAAClE,QAAA;EACnD;EAEA,MAAMmE,OAAOC,QAAgB,EAAE;IAC7B,MAAMD,MAAA,GAAS,IAAI,CAACtC,OAAO,CAACzB,GAAG,CAACgE,QAAA;IAChC,IAAID,MAAA,EAAQ;MACVA,MAAA;MACA,IAAI,CAACxC,KAAK,CAAC0C,MAAM,CAACD,QAAA;MAClB,IAAI,CAACvC,OAAO,CAACwC,MAAM,CAACD,QAAA;IACtB;EACF;EAEA,MAAME,KAAKF,QAAgB,EAAE;IAC3B,IACErC,OAAA,CAAQC,GAAG,CAACuC,iCAAiC,IAC7CxC,OAAA,CAAQC,GAAG,CAACwC,gCAAgC,IAC5CzC,OAAA,CAAQC,GAAG,CAACyC,YAAY,KAAK,QAC7B;MACA,MAAMC,eAAA,GAAkBC,OAAA,CAAQ,+BAC7BD,eAAe;MAElB,MAAMA,eAAA,CAAgB;QACpBE,MAAA,EAAQ;QACRC,OAAA,EAAS9C,OAAA,CAAQC,GAAG,CAACuC,iCAAiC;QACtDO,MAAA,EAAQ/C,OAAA,CAAQC,GAAG,CAACwC,gCAAgC;QACpDO,IAAA,EAAM,CAACX,QAAA;MACT;MAEA,OAAO;QACL,MAAMM,eAAA,CAAgB;UACpBE,MAAA,EAAQ;UACRC,OAAA,EAAS9C,OAAA,CAAQC,GAAG,CAACuC,iCAAiC;UACtDO,MAAA,EAAQ/C,OAAA,CAAQC,GAAG,CAACwC,gCAAgC;UACpDO,IAAA,EAAM,CAACX,QAAA;QACT;MACF;IACF;IAEA,IAAIY,UAAA,GAAkCA,CAAA,KAAMC,OAAA,CAAQC,OAAO;IAC3D,MAAMC,YAAA,GAAe,IAAI,CAACxD,KAAK,CAACvB,GAAG,CAACgE,QAAA;IAEpC,IAAIe,YAAA,EAAc;MAChB,MAAMA,YAAA;IACR,OAAO;MACL,MAAMC,OAAA,GAAU,IAAIH,OAAA,CAAeC,OAAA;QACjCF,UAAA,GAAa,MAAAA,CAAA;UACXE,OAAA;QACF;MACF;MAEA,IAAI,CAACvD,KAAK,CAACrB,GAAG,CAAC8D,QAAA,EAAUgB,OAAA;MACzB,IAAI,CAACvD,OAAO,CAACvB,GAAG,CAAC8D,QAAA,EAAUY,UAAA;IAC7B;IAEA,OAAOA,UAAA;EACT;EAEA,MAAMzE,cAAc8E,GAAW,EAAE;QAgBxBC,gCAAA,EAAAC,kBAAA;IAfP,IACExD,OAAA,CAAQC,GAAG,CAACuC,iCAAiC,IAC7CxC,OAAA,CAAQC,GAAG,CAACwC,gCAAgC,IAC5CzC,OAAA,CAAQC,GAAG,CAACyC,YAAY,KAAK,QAC7B;MACA,MAAMC,eAAA,GAAkBC,OAAA,CAAQ,+BAC7BD,eAAe;MAClB,OAAOA,eAAA,CAAgB;QACrBE,MAAA,EAAQ;QACRC,OAAA,EAAS9C,OAAA,CAAQC,GAAG,CAACuC,iCAAiC;QACtDO,MAAA,EAAQ/C,OAAA,CAAQC,GAAG,CAACwC,gCAAgC;QACpDO,IAAA,EAAM,C,GAAIS,SAAA;MACZ;IACF;IAEA,QAAOD,kBAAA,OAAI,CAAChC,YAAY,sBAAjB+B,gCAAA,GAAAC,kBAAA,CAAmBhF,aAAa,qBAAhC+E,gCAAA,CAAAG,IAAA,CAAAF,kBAAA,EAAmCF,GAAA;EAC5C;EAEA;EACA,MAAMK,cACJC,GAAW,EACXC,IAAA,GAA8B,CAAC,CAAC,EACf;IACjB;IACA;IACA,MAAMC,eAAA,GAAkB;IAExB,IAAIzB,QAAA;IACJ,MAAM0B,UAAA,GAAuB,EAAE;IAE/B,MAAMC,OAAA,GAAU,IAAIC,WAAA;IACpB,MAAMC,OAAA,GAAU,IAAIC,WAAA;IAEpB,IAAIN,IAAA,CAAKO,IAAI,EAAE;MACb;MACA,IAAI,OAAOP,IAAC,CAAKO,IAAI,CAASC,SAAS,KAAK,YAAY;QACtD,MAAMC,YAAA,GAAeT,IAAA,CAAKO,IAAI;QAE9B,MAAMG,MAAA,GAAuB,EAAE;QAE/B,IAAI;UACF,MAAMD,YAAA,CAAaE,MAAM,CACvB,IAAIC,cAAA,CAAe;YACjBC,MAAMC,KAAK;cACT,IAAI,OAAOA,KAAA,KAAU,UAAU;gBAC7BJ,MAAA,CAAOK,IAAI,CAACZ,OAAA,CAAQa,MAAM,CAACF,KAAA;gBAC3BZ,UAAA,CAAWa,IAAI,CAACD,KAAA;cAClB,OAAO;gBACLJ,MAAA,CAAOK,IAAI,CAACD,KAAA;gBACZZ,UAAA,CAAWa,IAAI,CAACV,OAAA,CAAQY,MAAM,CAACH,KAAA,EAAO;kBAAEI,MAAA,EAAQ;gBAAK;cACvD;YACF;UACF;UAGF;UACAhB,UAAA,CAAWa,IAAI,CAACV,OAAA,CAAQY,MAAM;UAE9B;UACA,MAAME,MAAA,GAAST,MAAA,CAAOU,MAAM,CAAC,CAACC,KAAA,EAAOC,GAAA,KAAQD,KAAA,GAAQC,GAAA,CAAIH,MAAM,EAAE;UACjE,MAAMI,WAAA,GAAc,IAAIC,UAAA,CAAWL,MAAA;UAEnC;UACA,IAAIM,MAAA,GAAS;UACb,KAAK,MAAMX,KAAA,IAASJ,MAAA,EAAQ;YAC1Ba,WAAA,CAAY7G,GAAG,CAACoG,KAAA,EAAOW,MAAA;YACvBA,MAAA,IAAUX,KAAA,CAAMK,MAAM;UACxB;UAEEnB,IAAA,CAAa0B,OAAO,GAAGH,WAAA;QAC3B,EAAE,OAAOI,GAAA,EAAK;UACZrF,OAAA,CAAQsF,KAAK,CAAC,wBAAwBD,GAAA;QACxC;MACF,OACK,IAAI,OAAO3B,IAAC,CAAKO,IAAI,CAASsB,IAAI,KAAK,YAAY;QACtD,MAAMC,QAAA,GAAW9B,IAAA,CAAKO,IAAI;QACxBP,IAAA,CAAa0B,OAAO,GAAG1B,IAAA,CAAKO,IAAI;QAClC,KAAK,MAAMwB,GAAA,IAAO,IAAIC,GAAA,CAAI,C,GAAIF,QAAA,CAASD,IAAI,GAAG,GAAG;UAC/C,MAAMI,MAAA,GAASH,QAAA,CAASI,MAAM,CAACH,GAAA;UAC/B7B,UAAA,CAAWa,IAAI,CACZ,GAAEgB,GAAI,IAAG,CACR,MAAM1C,OAAA,CAAQ8C,GAAG,CACfF,MAAA,CAAOG,GAAG,CAAC,MAAOC,GAAA;YAChB,IAAI,OAAOA,GAAA,KAAQ,UAAU;cAC3B,OAAOA,GAAA;YACT,OAAO;cACL,OAAO,MAAMA,GAAA,CAAIC,IAAI;YACvB;UACF,GACF,EACAC,IAAI,CAAC,IAAK,EAAC;QAEjB;QACA;MACF,OAAO,IAAI,OAAOvC,IAAC,CAAKO,IAAI,CAASgB,WAAW,KAAK,YAAY;QAC/D,MAAMiB,IAAA,GAAOxC,IAAA,CAAKO,IAAI;QACtB,MAAMgB,WAAA,GAAc,MAAMiB,IAAA,CAAKjB,WAAW;QAC1CrB,UAAA,CAAWa,IAAI,CAAC,MAAMyB,IAAA,CAAKF,IAAI;QAC7BtC,IAAA,CAAa0B,OAAO,GAAG,IAAIe,IAAA,CAAK,CAAClB,WAAA,CAAY,EAAE;UAAEmB,IAAA,EAAMF,IAAA,CAAKE;QAAK;MACrE,OAAO,IAAI,OAAO1C,IAAA,CAAKO,IAAI,KAAK,UAAU;QACxCL,UAAA,CAAWa,IAAI,CAACf,IAAA,CAAKO,IAAI;QACvBP,IAAA,CAAa0B,OAAO,GAAG1B,IAAA,CAAKO,IAAI;MACpC;IACF;IAEA,MAAMoC,WAAA,GAAcC,IAAA,CAAKC,SAAS,CAAC,CACjC5C,eAAA,EACA,IAAI,CAACzE,mBAAmB,IAAI,IAC5BuE,GAAA,EACAC,IAAA,CAAKhB,MAAM,EACX,OAAO,CAACgB,IAAA,CAAK8C,OAAO,IAAI,CAAC,GAAGjB,IAAI,KAAK,aACjCkB,MAAA,CAAOC,WAAW,CAAChD,IAAA,CAAK8C,OAAO,IAC/B9C,IAAA,CAAK8C,OAAO,EAChB9C,IAAA,CAAKiD,IAAI,EACTjD,IAAA,CAAKkD,QAAQ,EACblD,IAAA,CAAKmD,WAAW,EAChBnD,IAAA,CAAKoD,QAAQ,EACbpD,IAAA,CAAKqD,cAAc,EACnBrD,IAAA,CAAKsD,SAAS,EACdtD,IAAA,CAAKuD,KAAK,EACVrD,UAAA,CACD;IAED,IAAI/D,OAAA,CAAQC,GAAG,CAACyC,YAAY,KAAK,QAAQ;MACvC,SAAS2E,YAAYC,MAAmB;QACtC,OAAOC,KAAA,CAAMC,SAAS,CAACvB,GAAG,CACvBvC,IAAI,CAAC,IAAI2B,UAAA,CAAWiC,MAAA,GAAUG,CAAA,IAAMA,CAAA,CAAEC,QAAQ,CAAC,IAAIC,QAAQ,CAAC,GAAG,MAC/DvB,IAAI,CAAC;MACV;MACA,MAAMkB,MAAA,GAAStD,OAAA,CAAQa,MAAM,CAAC2B,WAAA;MAC9BnE,QAAA,GAAWgF,WAAA,CAAY,MAAMO,MAAA,CAAOC,MAAM,CAACC,MAAM,CAAC,WAAWR,MAAA;IAC/D,OAAO;MACL,MAAMS,OAAA,GAASnF,OAAA,CAAQ;MACvBP,QAAA,GAAW0F,OAAA,CAAOC,UAAU,CAAC,UAAUC,MAAM,CAACzB,WAAA,EAAasB,MAAM,CAAC;IACpE;IACA,OAAOzF,QAAA;EACT;EAEA;EACA,MAAMhE,IACJgE,QAAgB,EAChB6F,GAAA,GAOI,CAAC,CAAC,EACiC;QA8Bf1E,kBAAA,EAEpB2E,gBAAA,EA+BFC,sCAAA;IA9DF,IACEpI,OAAA,CAAQC,GAAG,CAACuC,iCAAiC,IAC7CxC,OAAA,CAAQC,GAAG,CAACwC,gCAAgC,IAC5CzC,OAAA,CAAQC,GAAG,CAACyC,YAAY,KAAK,QAC7B;MACA,MAAMC,eAAA,GAAkBC,OAAA,CAAQ,+BAC7BD,eAAe;MAElB,OAAOA,eAAA,CAAgB;QACrBE,MAAA,EAAQ;QACRC,OAAA,EAAS9C,OAAA,CAAQC,GAAG,CAACuC,iCAAiC;QACtDO,MAAA,EAAQ/C,OAAA,CAAQC,GAAG,CAACwC,gCAAgC;QACpDO,IAAA,EAAM,C,GAAIS,SAAA;MACZ;IACF;IAEA;IACA;IACA,IACE,IAAI,CAAC9E,GAAG,KACP,CAACuJ,GAAA,CAAIpJ,UAAU,IAAI,IAAI,CAACG,cAAc,CAAC,gBAAgB,KAAK,UAAS,GACtE;MACA,OAAO;IACT;IAEAoD,QAAA,GAAW,IAAI,CAACJ,YAAY,CAACI,QAAA,EAAU6F,GAAA,CAAIpJ,UAAU;IACrD,IAAIuJ,KAAA,GAAsC;IAC1C,IAAIC,UAAA,GAAaJ,GAAA,CAAII,UAAU;IAE/B,MAAMC,SAAA,GAAY,QAAM/E,kBAAA,OAAI,CAAChC,YAAY,qBAAjBgC,kBAAA,CAAmBnF,GAAG,CAACgE,QAAA,EAAU6F,GAAA;IAEzD,IAAI,CAAAK,SAAA,qBAAAJ,gBAAA,GAAAI,SAAA,CAAWC,KAAK,qBAAhBL,gBAAA,CAAkBM,IAAI,MAAK,SAAS;MACtC,MAAMC,YAAA,GAAe,C,IAAKR,GAAA,CAAIS,IAAI,IAAI,EAAE,G,IAAOT,GAAA,CAAIU,QAAQ,IAAI,EAAE,EAAE;MACnE;MACA,IACEF,YAAA,CAAaG,IAAI,CAAEvF,GAAA;YACVwF,qBAAA;QAAP,QAAOA,qBAAA,OAAI,CAAC/H,eAAe,qBAApB+H,qBAAA,CAAsBC,QAAQ,CAACzF,GAAA;MACxC,IACA;QACA,OAAO;MACT;MAEAgF,UAAA,GAAaA,UAAA,IAAcC,SAAA,CAAUC,KAAK,CAACF,UAAU;MACrD,MAAMU,GAAA,GAAMC,IAAA,CAAKC,KAAK,CACpB,CAACtH,IAAA,CAAKuH,GAAG,MAAMZ,SAAA,CAAUa,YAAY,IAAI,EAAC,IAAK;MAGjD,MAAMC,OAAA,GAAUL,GAAA,GAAMV,UAAA;MACtB,MAAMgB,IAAA,GAAOf,SAAA,CAAUC,KAAK,CAACc,IAAI;MAEjC,OAAO;QACLD,OAAA,EAASA,OAAA;QACTb,KAAA,EAAO;UACLC,IAAA,EAAM;UACNa,IAAA;UACAhB,UAAA,EAAYA;QACd;QACAtG,eAAA,EAAiBJ,IAAA,CAAKuH,GAAG,KAAKb,UAAA,GAAa;MAC7C;IACF;IAEA,MAAMiB,aAAA,IACJnB,sCAAA,OAAI,CAACtH,iBAAiB,CAACiB,MAAM,CAAC/D,OAAA,CAAQqE,QAAA,EAAU,qBAAhD+F,sCAAA,CAAkDtG,wBAAwB;IAE5E,IAAIuH,OAAA;IACJ,IAAIrH,eAAA;IAEJ,IAAI,CAAAuG,SAAA,oBAAAA,SAAA,CAAWa,YAAY,MAAK,CAAC,GAAG;MAClCC,OAAA,GAAU,CAAC;MACXrH,eAAA,GAAkB,CAAC,IAAIhB,UAAA,CAAAwI,cAAc;IACvC,OAAO;MACLxH,eAAA,GAAkB,IAAI,CAACN,mBAAmB,CACxCW,QAAA,EACA,CAAAkG,SAAA,oBAAAA,SAAA,CAAWa,YAAY,KAAIxH,IAAA,CAAKuH,GAAG,IACnC,IAAI,CAACxK,GAAG,IAAI,CAACuJ,GAAA,CAAIpJ,UAAU;MAE7BuK,OAAA,GACErH,eAAA,KAAoB,SAASA,eAAA,GAAkBJ,IAAA,CAAKuH,GAAG,KACnD,OACAM,SAAA;IACR;IAEA,IAAIlB,SAAA,EAAW;MACbF,KAAA,GAAQ;QACNgB,OAAA;QACAE,aAAA;QACAvH,eAAA;QACAwG,KAAA,EAAOD,SAAA,CAAUC;MACnB;IACF;IAEA,IACE,CAACD,SAAA,IACD,IAAI,CAACzH,iBAAiB,CAAC4I,cAAc,CAACX,QAAQ,CAAC1G,QAAA,GAC/C;MACA;MACA;MACA;MACA;MACA;MACAgG,KAAA,GAAQ;QACNgB,OAAA;QACAb,KAAA,EAAO;QACPe,aAAA;QACAvH;MACF;MACA,IAAI,CAACzD,GAAG,CAAC8D,QAAA,EAAUgG,KAAA,CAAMG,KAAK,EAAEN,GAAA;IAClC;IACA,OAAOG,KAAA;EACT;EAEA;EACA,MAAM9J,IACJN,QAAgB,EAChBqL,IAAkC,EAClCpB,GAMC,EACD;IACA,IACElI,OAAA,CAAQC,GAAG,CAACuC,iCAAiC,IAC7CxC,OAAA,CAAQC,GAAG,CAACwC,gCAAgC,IAC5CzC,OAAA,CAAQC,GAAG,CAACyC,YAAY,KAAK,QAC7B;MACA,MAAMC,eAAA,GAAkBC,OAAA,CAAQ,+BAC7BD,eAAe;MAElB,OAAOA,eAAA,CAAgB;QACrBE,MAAA,EAAQ;QACRC,OAAA,EAAS9C,OAAA,CAAQC,GAAG,CAACuC,iCAAiC;QACtDO,MAAA,EAAQ/C,OAAA,CAAQC,GAAG,CAACwC,gCAAgC;QACpDO,IAAA,EAAM,C,GAAIS,SAAA;MACZ;IACF;IAEA,IAAI,IAAI,CAAC9E,GAAG,IAAI,CAACuJ,GAAA,CAAIpJ,UAAU,EAAE;IACjC;IACA,IAAIoJ,GAAA,CAAIpJ,UAAU,IAAI2H,IAAA,CAAKC,SAAS,CAAC4C,IAAA,EAAMtE,MAAM,GAAG,IAAI,OAAO,MAAM;MACnE,IAAI,IAAI,CAACrG,GAAG,EAAE;QACZ,MAAM,IAAIgL,KAAA,CAAO,8CAA6C;MAChE;MACA;IACF;IAEA1L,QAAA,GAAW,IAAI,CAACgE,YAAY,CAAChE,QAAA,EAAUiK,GAAA,CAAIpJ,UAAU;IAErD,IAAI;UAcI0E,kBAAA;MAbN;MACA;MACA;MACA,IAAI,OAAO0E,GAAA,CAAII,UAAU,KAAK,eAAe,CAACJ,GAAA,CAAIpJ,UAAU,EAAE;QAC5D,IAAI,CAACgC,iBAAiB,CAACiB,MAAM,CAAC9D,QAAA,CAAS,GAAG;UACxC2L,SAAA,EAAWC,KAAA,CAAAvJ,OAAI,CAACwJ,KAAK,CAAC1D,IAAI,CACxB,eACC,GAAE,IAAAlE,kBAAA,CAAAC,iBAAiB,EAAClE,QAAA,CAAU,OAAM;UAEvC8L,QAAA,EAAU;UACVjI,wBAAA,EAA0BoG,GAAA,CAAII;QAChC;MACF;MACA,QAAM9E,kBAAA,OAAI,CAAChC,YAAY,qBAAjBgC,kBAAA,CAAmBjF,GAAG,CAACN,QAAA,EAAUqL,IAAA,EAAMpB,GAAA;IAC/C,EAAE,OAAOzC,KAAA,EAAO;MACdtF,OAAA,CAAQ6J,IAAI,CAAC,wCAAwC/L,QAAA,EAAUwH,KAAA;IACjE;EACF;AACF"},"metadata":{},"sourceType":"script","externalDependencies":[]}