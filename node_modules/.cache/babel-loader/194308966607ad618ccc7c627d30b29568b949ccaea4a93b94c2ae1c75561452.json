{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"recursiveReadDir\", {\n  enumerable: true,\n  get: function () {\n    return recursiveReadDir;\n  }\n});\nconst _promises = /*#__PURE__*/_interop_require_default(require(\"fs/promises\"));\nconst _path = /*#__PURE__*/_interop_require_default(require(\"path\"));\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nasync function recursiveReadDir(rootDirectory, options = {}) {\n  // Grab our options.\n  const {\n    pathnameFilter,\n    ignoreFilter,\n    ignorePartFilter,\n    sortPathnames = true,\n    relativePathnames = true\n  } = options;\n  // The list of pathnames to return.\n  const pathnames = [];\n  /**\n  * Coerces the pathname to be relative if requested.\n  */\n  const coerce = relativePathnames ? pathname => pathname.replace(rootDirectory, \"\") : pathname => pathname;\n  // The queue of directories to scan.\n  let directories = [rootDirectory];\n  while (directories.length > 0) {\n    // Load all the files in each directory at the same time.\n    const results = await Promise.all(directories.map(async directory => {\n      const result = {\n        directories: [],\n        pathnames: [],\n        links: []\n      };\n      try {\n        const dir = await _promises.default.readdir(directory, {\n          withFileTypes: true\n        });\n        for (const file of dir) {\n          // If enabled, ignore the file if it matches the ignore filter.\n          if (ignorePartFilter && ignorePartFilter(file.name)) {\n            continue;\n          }\n          // Handle each file.\n          const absolutePathname = _path.default.join(directory, file.name);\n          // If enabled, ignore the file if it matches the ignore filter.\n          if (ignoreFilter && ignoreFilter(absolutePathname)) {\n            continue;\n          }\n          // If the file is a directory, then add it to the list of directories,\n          // they'll be scanned on a later pass.\n          if (file.isDirectory()) {\n            result.directories.push(absolutePathname);\n          } else if (file.isSymbolicLink()) {\n            result.links.push(absolutePathname);\n          } else if (!pathnameFilter || pathnameFilter(absolutePathname)) {\n            result.pathnames.push(coerce(absolutePathname));\n          }\n        }\n      } catch (err) {\n        // This can only happen when the underlying directory was removed. If\n        // anything other than this error occurs, re-throw it.\n        // if (err.code !== 'ENOENT') throw err\n        if (err.code !== \"ENOENT\" || directory === rootDirectory) throw err;\n        // The error occurred, so abandon reading this directory.\n        return null;\n      }\n      return result;\n    }));\n    // Empty the directories, we'll fill it later if some of the files are\n    // directories.\n    directories = [];\n    // Keep track of any symbolic links we find, we'll resolve them later.\n    const links = [];\n    // For each result of directory scans...\n    for (const result of results) {\n      // If the directory was removed, then skip it.\n      if (!result) continue;\n      // Add any directories to the list of directories to scan.\n      directories.push(...result.directories);\n      // Add any symbolic links to the list of symbolic links to resolve.\n      links.push(...result.links);\n      // Add any file pathnames to the list of pathnames.\n      pathnames.push(...result.pathnames);\n    }\n    // Resolve all the symbolic links we found if any.\n    if (links.length > 0) {\n      const resolved = await Promise.all(links.map(async absolutePathname => {\n        try {\n          return await _promises.default.stat(absolutePathname);\n        } catch (err) {\n          // This can only happen when the underlying link was removed. If\n          // anything other than this error occurs, re-throw it.\n          if (err.code !== \"ENOENT\") throw err;\n          // The error occurred, so abandon reading this directory.\n          return null;\n        }\n      }));\n      for (let i = 0; i < links.length; i++) {\n        const stats = resolved[i];\n        // If the link was removed, then skip it.\n        if (!stats) continue;\n        // We would have already ignored the file if it matched the ignore\n        // filter, so we don't need to check it again.\n        const absolutePathname = links[i];\n        if (stats.isDirectory()) {\n          directories.push(absolutePathname);\n        } else if (!pathnameFilter || pathnameFilter(absolutePathname)) {\n          pathnames.push(coerce(absolutePathname));\n        }\n      }\n    }\n  }\n  // Sort the pathnames in place if requested.\n  if (sortPathnames) {\n    pathnames.sort();\n  }\n  return pathnames;\n}","map":{"version":3,"names":["recursiveReadDir","rootDirectory","options","pathnameFilter","ignoreFilter","ignorePartFilter","sortPathnames","relativePathnames","pathnames","coerce","pathname","replace","directories","length","results","Promise","all","map","directory","result","links","dir","_promises","default","readdir","withFileTypes","file","name","absolutePathname","_path","join","isDirectory","push","isSymbolicLink","err","code","resolved","stat","i","stats","sort"],"sources":["../../src/lib/recursive-readdir.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}