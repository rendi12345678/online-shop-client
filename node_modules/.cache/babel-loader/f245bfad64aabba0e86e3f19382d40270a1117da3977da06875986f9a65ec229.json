{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: function () {\n    return FetchCache;\n  }\n});\nconst _lrucache = /*#__PURE__*/_interop_require_default(require(\"next/dist/compiled/lru-cache\"));\nconst _constants = require(\"../../../lib/constants\");\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nlet rateLimitedUntil = 0;\nlet memoryCache;\nconst CACHE_TAGS_HEADER = \"x-vercel-cache-tags\";\nconst CACHE_HEADERS_HEADER = \"x-vercel-sc-headers\";\nconst CACHE_STATE_HEADER = \"x-vercel-cache-state\";\nconst CACHE_REVALIDATE_HEADER = \"x-vercel-revalidate\";\nconst CACHE_FETCH_URL_HEADER = \"x-vercel-cache-item-name\";\nconst CACHE_CONTROL_VALUE_HEADER = \"x-vercel-cache-control\";\nclass FetchCache {\n  static isAvailable(ctx) {\n    return !!(ctx._requestHeaders[\"x-vercel-sc-host\"] || process.env.SUSPENSE_CACHE_URL);\n  }\n  constructor(ctx) {\n    this.debug = !!process.env.NEXT_PRIVATE_DEBUG_CACHE;\n    this.headers = {};\n    this.headers[\"Content-Type\"] = \"application/json\";\n    if (CACHE_HEADERS_HEADER in ctx._requestHeaders) {\n      const newHeaders = JSON.parse(ctx._requestHeaders[CACHE_HEADERS_HEADER]);\n      for (const k in newHeaders) {\n        this.headers[k] = newHeaders[k];\n      }\n      delete ctx._requestHeaders[CACHE_HEADERS_HEADER];\n    }\n    const scHost = ctx._requestHeaders[\"x-vercel-sc-host\"] || process.env.SUSPENSE_CACHE_URL;\n    const scBasePath = ctx._requestHeaders[\"x-vercel-sc-basepath\"] || process.env.SUSPENSE_CACHE_BASEPATH;\n    if (process.env.SUSPENSE_CACHE_AUTH_TOKEN) {\n      this.headers[\"Authorization\"] = `Bearer ${process.env.SUSPENSE_CACHE_AUTH_TOKEN}`;\n    }\n    if (scHost) {\n      this.cacheEndpoint = `https://${scHost}${scBasePath || \"\"}`;\n      if (this.debug) {\n        console.log(\"using cache endpoint\", this.cacheEndpoint);\n      }\n    } else if (this.debug) {\n      console.log(\"no cache endpoint available\");\n    }\n    if (ctx.maxMemoryCacheSize) {\n      if (!memoryCache) {\n        if (this.debug) {\n          console.log(\"using memory store for fetch cache\");\n        }\n        memoryCache = new _lrucache.default({\n          max: ctx.maxMemoryCacheSize,\n          length({\n            value\n          }) {\n            var _JSON_stringify;\n            if (!value) {\n              return 25;\n            } else if (value.kind === \"REDIRECT\") {\n              return JSON.stringify(value.props).length;\n            } else if (value.kind === \"IMAGE\") {\n              throw new Error(\"invariant image should not be incremental-cache\");\n            } else if (value.kind === \"FETCH\") {\n              return JSON.stringify(value.data || \"\").length;\n            } else if (value.kind === \"ROUTE\") {\n              return value.body.length;\n            }\n            // rough estimate of size of cache value\n            return value.html.length + (((_JSON_stringify = JSON.stringify(value.pageData)) == null ? void 0 : _JSON_stringify.length) || 0);\n          }\n        });\n      }\n    } else {\n      if (this.debug) {\n        console.log(\"not using memory store for fetch cache\");\n      }\n    }\n  }\n  async revalidateTag(tag) {\n    if (this.debug) {\n      console.log(\"revalidateTag\", tag);\n    }\n    if (Date.now() < rateLimitedUntil) {\n      if (this.debug) {\n        console.log(\"rate limited \", rateLimitedUntil);\n      }\n      return;\n    }\n    try {\n      const res = await fetch(`${this.cacheEndpoint}/v1/suspense-cache/revalidate?tags=${tag}`, {\n        method: \"POST\",\n        headers: this.headers,\n        // @ts-expect-error not on public type\n        next: {\n          internal: true\n        }\n      });\n      if (res.status === 429) {\n        const retryAfter = res.headers.get(\"retry-after\") || \"60000\";\n        rateLimitedUntil = Date.now() + parseInt(retryAfter);\n      }\n      if (!res.ok) {\n        throw new Error(`Request failed with status ${res.status}.`);\n      }\n    } catch (err) {\n      console.warn(`Failed to revalidate tag ${tag}`, err);\n    }\n  }\n  async get(key, ctx) {\n    const {\n      tags,\n      softTags,\n      fetchCache,\n      fetchIdx,\n      fetchUrl\n    } = ctx;\n    if (!fetchCache) return null;\n    if (Date.now() < rateLimitedUntil) {\n      if (this.debug) {\n        console.log(\"rate limited\");\n      }\n      return null;\n    }\n    let data = memoryCache == null ? void 0 : memoryCache.get(key);\n    // memory cache data is only leveraged for up to 1 seconds\n    // so that revalidation events can be pulled from source\n    if (Date.now() - ((data == null ? void 0 : data.lastModified) || 0) > 2000) {\n      data = undefined;\n    }\n    // get data from fetch cache\n    if (!data && this.cacheEndpoint) {\n      try {\n        const start = Date.now();\n        const fetchParams = {\n          internal: true,\n          fetchType: \"cache-get\",\n          fetchUrl: fetchUrl,\n          fetchIdx\n        };\n        const res = await fetch(`${this.cacheEndpoint}/v1/suspense-cache/${key}`, {\n          method: \"GET\",\n          headers: {\n            ...this.headers,\n            [CACHE_FETCH_URL_HEADER]: fetchUrl,\n            [CACHE_TAGS_HEADER]: (tags == null ? void 0 : tags.join(\",\")) || \"\",\n            [_constants.NEXT_CACHE_SOFT_TAGS_HEADER]: (softTags == null ? void 0 : softTags.join(\",\")) || \"\"\n          },\n          next: fetchParams\n        });\n        if (res.status === 429) {\n          const retryAfter = res.headers.get(\"retry-after\") || \"60000\";\n          rateLimitedUntil = Date.now() + parseInt(retryAfter);\n        }\n        if (res.status === 404) {\n          if (this.debug) {\n            console.log(`no fetch cache entry for ${key}, duration: ${Date.now() - start}ms`);\n          }\n          return null;\n        }\n        if (!res.ok) {\n          console.error(await res.text());\n          throw new Error(`invalid response from cache ${res.status}`);\n        }\n        const cached = await res.json();\n        if (!cached || cached.kind !== \"FETCH\") {\n          this.debug && console.log({\n            cached\n          });\n          throw new Error(`invalid cache value`);\n        }\n        const cacheState = res.headers.get(CACHE_STATE_HEADER);\n        const age = res.headers.get(\"age\");\n        data = {\n          value: cached,\n          // if it's already stale set it to a time in the past\n          // if not derive last modified from age\n          lastModified: cacheState !== \"fresh\" ? Date.now() - _constants.CACHE_ONE_YEAR : Date.now() - parseInt(age || \"0\", 10) * 1000\n        };\n        if (this.debug) {\n          console.log(`got fetch cache entry for ${key}, duration: ${Date.now() - start}ms, size: ${Object.keys(cached).length}, cache-state: ${cacheState} tags: ${tags == null ? void 0 : tags.join(\",\")} softTags: ${softTags == null ? void 0 : softTags.join(\",\")}`);\n        }\n        if (data) {\n          memoryCache == null ? void 0 : memoryCache.set(key, data);\n        }\n      } catch (err) {\n        // unable to get data from fetch-cache\n        if (this.debug) {\n          console.error(`Failed to get from fetch-cache`, err);\n        }\n      }\n    }\n    return data || null;\n  }\n  async set(key, data, {\n    fetchCache,\n    fetchIdx,\n    fetchUrl,\n    tags\n  }) {\n    if (!fetchCache) return;\n    if (Date.now() < rateLimitedUntil) {\n      if (this.debug) {\n        console.log(\"rate limited\");\n      }\n      return;\n    }\n    memoryCache == null ? void 0 : memoryCache.set(key, {\n      value: data,\n      lastModified: Date.now()\n    });\n    if (this.cacheEndpoint) {\n      try {\n        const start = Date.now();\n        if (data !== null && \"revalidate\" in data) {\n          this.headers[CACHE_REVALIDATE_HEADER] = data.revalidate.toString();\n        }\n        if (!this.headers[CACHE_REVALIDATE_HEADER] && data !== null && \"data\" in data) {\n          this.headers[CACHE_CONTROL_VALUE_HEADER] = data.data.headers[\"cache-control\"];\n        }\n        const body = JSON.stringify({\n          ...data,\n          // we send the tags in the header instead\n          // of in the body here\n          tags: undefined\n        });\n        if (this.debug) {\n          console.log(\"set cache\", key);\n        }\n        const fetchParams = {\n          internal: true,\n          fetchType: \"cache-set\",\n          fetchUrl,\n          fetchIdx\n        };\n        const res = await fetch(`${this.cacheEndpoint}/v1/suspense-cache/${key}`, {\n          method: \"POST\",\n          headers: {\n            ...this.headers,\n            [CACHE_FETCH_URL_HEADER]: fetchUrl || \"\",\n            [CACHE_TAGS_HEADER]: (tags == null ? void 0 : tags.join(\",\")) || \"\"\n          },\n          body: body,\n          next: fetchParams\n        });\n        if (res.status === 429) {\n          const retryAfter = res.headers.get(\"retry-after\") || \"60000\";\n          rateLimitedUntil = Date.now() + parseInt(retryAfter);\n        }\n        if (!res.ok) {\n          this.debug && console.log(await res.text());\n          throw new Error(`invalid response ${res.status}`);\n        }\n        if (this.debug) {\n          console.log(`successfully set to fetch-cache for ${key}, duration: ${Date.now() - start}ms, size: ${body.length}`);\n        }\n      } catch (err) {\n        // unable to set to fetch-cache\n        if (this.debug) {\n          console.error(`Failed to update fetch cache`, err);\n        }\n      }\n    }\n    return;\n  }\n}","map":{"version":3,"names":["FetchCache","rateLimitedUntil","memoryCache","CACHE_TAGS_HEADER","CACHE_HEADERS_HEADER","CACHE_STATE_HEADER","CACHE_REVALIDATE_HEADER","CACHE_FETCH_URL_HEADER","CACHE_CONTROL_VALUE_HEADER","isAvailable","ctx","_requestHeaders","process","env","SUSPENSE_CACHE_URL","constructor","debug","NEXT_PRIVATE_DEBUG_CACHE","headers","newHeaders","JSON","parse","k","scHost","scBasePath","SUSPENSE_CACHE_BASEPATH","SUSPENSE_CACHE_AUTH_TOKEN","cacheEndpoint","console","log","maxMemoryCacheSize","_lrucache","default","max","length","value","_JSON_stringify","kind","stringify","props","Error","data","body","html","pageData","revalidateTag","tag","Date","now","res","fetch","method","next","internal","status","retryAfter","get","parseInt","ok","err","warn","key","tags","softTags","fetchCache","fetchIdx","fetchUrl","lastModified","undefined","start","fetchParams","fetchType","join","_constants","NEXT_CACHE_SOFT_TAGS_HEADER","error","text","cached","json","cacheState","age","CACHE_ONE_YEAR","Object","keys","set","revalidate","toString"],"sources":["../../../../src/server/lib/incremental-cache/fetch-cache.ts"],"sourcesContent":[null],"mappings":";;;;;+BAyBA;;;WAAqBA,UAAA;;;gEAvBA;2BAId;;;;;;AAEP,IAAIC,gBAAA,GAAmB;AACvB,IAAIC,WAAA;AASJ,MAAMC,iBAAA,GAAoB;AAC1B,MAAMC,oBAAA,GAAuB;AAC7B,MAAMC,kBAAA,GAAqB;AAC3B,MAAMC,uBAAA,GAA0B;AAChC,MAAMC,sBAAA,GAAyB;AAC/B,MAAMC,0BAAA,GAA6B;AAEpB,MAAMR,UAAA;EAKnB,OAAOS,YAAYC,GAElB,EAAE;IACD,OAAO,CAAC,EACNA,GAAA,CAAIC,eAAe,CAAC,mBAAmB,IAAIC,OAAA,CAAQC,GAAG,CAACC,kBAAkB,CAAD;EAE5E;EAEAC,YAAYL,GAAwB,EAAE;IACpC,IAAI,CAACM,KAAK,GAAG,CAAC,CAACJ,OAAA,CAAQC,GAAG,CAACI,wBAAwB;IACnD,IAAI,CAACC,OAAO,GAAG,CAAC;IAChB,IAAI,CAACA,OAAO,CAAC,eAAe,GAAG;IAE/B,IAAId,oBAAA,IAAwBM,GAAA,CAAIC,eAAe,EAAE;MAC/C,MAAMQ,UAAA,GAAaC,IAAA,CAAKC,KAAK,CAC3BX,GAAA,CAAIC,eAAe,CAACP,oBAAA,CAAqB;MAE3C,KAAK,MAAMkB,CAAA,IAAKH,UAAA,EAAY;QAC1B,IAAI,CAACD,OAAO,CAACI,CAAA,CAAE,GAAGH,UAAU,CAACG,CAAA,CAAE;MACjC;MACA,OAAOZ,GAAA,CAAIC,eAAe,CAACP,oBAAA,CAAqB;IAClD;IACA,MAAMmB,MAAA,GACJb,GAAA,CAAIC,eAAe,CAAC,mBAAmB,IAAIC,OAAA,CAAQC,GAAG,CAACC,kBAAkB;IAE3E,MAAMU,UAAA,GACJd,GAAA,CAAIC,eAAe,CAAC,uBAAuB,IAC3CC,OAAA,CAAQC,GAAG,CAACY,uBAAuB;IAErC,IAAIb,OAAA,CAAQC,GAAG,CAACa,yBAAyB,EAAE;MACzC,IAAI,CAACR,OAAO,CACV,gBACD,GAAI,UAASN,OAAA,CAAQC,GAAG,CAACa,yBAA0B,EAAC;IACvD;IAEA,IAAIH,MAAA,EAAQ;MACV,IAAI,CAACI,aAAa,GAAI,WAAUJ,MAAO,GAAEC,UAAA,IAAc,EAAG,EAAC;MAC3D,IAAI,IAAI,CAACR,KAAK,EAAE;QACdY,OAAA,CAAQC,GAAG,CAAC,wBAAwB,IAAI,CAACF,aAAa;MACxD;IACF,OAAO,IAAI,IAAI,CAACX,KAAK,EAAE;MACrBY,OAAA,CAAQC,GAAG,CAAC;IACd;IAEA,IAAInB,GAAA,CAAIoB,kBAAkB,EAAE;MAC1B,IAAI,CAAC5B,WAAA,EAAa;QAChB,IAAI,IAAI,CAACc,KAAK,EAAE;UACdY,OAAA,CAAQC,GAAG,CAAC;QACd;QAEA3B,WAAA,GAAc,IAAI6B,SAAA,CAAAC,OAAQ,CAAC;UACzBC,GAAA,EAAKvB,GAAA,CAAIoB,kBAAkB;UAC3BI,OAAO;YAAEC;UAAK,CAAE;gBAcSC,eAAA;YAbvB,IAAI,CAACD,KAAA,EAAO;cACV,OAAO;YACT,OAAO,IAAIA,KAAA,CAAME,IAAI,KAAK,YAAY;cACpC,OAAOjB,IAAA,CAAKkB,SAAS,CAACH,KAAA,CAAMI,KAAK,EAAEL,MAAM;YAC3C,OAAO,IAAIC,KAAA,CAAME,IAAI,KAAK,SAAS;cACjC,MAAM,IAAIG,KAAA,CAAM;YAClB,OAAO,IAAIL,KAAA,CAAME,IAAI,KAAK,SAAS;cACjC,OAAOjB,IAAA,CAAKkB,SAAS,CAACH,KAAA,CAAMM,IAAI,IAAI,IAAIP,MAAM;YAChD,OAAO,IAAIC,KAAA,CAAME,IAAI,KAAK,SAAS;cACjC,OAAOF,KAAA,CAAMO,IAAI,CAACR,MAAM;YAC1B;YACA;YACA,OACEC,KAAA,CAAMQ,IAAI,CAACT,MAAM,IAAI,EAAAE,eAAA,GAAAhB,IAAA,CAAKkB,SAAS,CAACH,KAAA,CAAMS,QAAQ,sBAA7BR,eAAA,CAAgCF,MAAM,KAAI;UAEnE;QACF;MACF;IACF,OAAO;MACL,IAAI,IAAI,CAAClB,KAAK,EAAE;QACdY,OAAA,CAAQC,GAAG,CAAC;MACd;IACF;EACF;EAEA,MAAagB,cAAcC,GAAW,EAAE;IACtC,IAAI,IAAI,CAAC9B,KAAK,EAAE;MACdY,OAAA,CAAQC,GAAG,CAAC,iBAAiBiB,GAAA;IAC/B;IAEA,IAAIC,IAAA,CAAKC,GAAG,KAAK/C,gBAAA,EAAkB;MACjC,IAAI,IAAI,CAACe,KAAK,EAAE;QACdY,OAAA,CAAQC,GAAG,CAAC,iBAAiB5B,gBAAA;MAC/B;MACA;IACF;IAEA,IAAI;MACF,MAAMgD,GAAA,GAAM,MAAMC,KAAA,CACf,GAAE,IAAI,CAACvB,aAAc,sCAAqCmB,GAAI,EAAC,EAChE;QACEK,MAAA,EAAQ;QACRjC,OAAA,EAAS,IAAI,CAACA,OAAO;QACrB;QACAkC,IAAA,EAAM;UAAEC,QAAA,EAAU;QAAK;MACzB;MAGF,IAAIJ,GAAA,CAAIK,MAAM,KAAK,KAAK;QACtB,MAAMC,UAAA,GAAaN,GAAA,CAAI/B,OAAO,CAACsC,GAAG,CAAC,kBAAkB;QACrDvD,gBAAA,GAAmB8C,IAAA,CAAKC,GAAG,KAAKS,QAAA,CAASF,UAAA;MAC3C;MAEA,IAAI,CAACN,GAAA,CAAIS,EAAE,EAAE;QACX,MAAM,IAAIlB,KAAA,CAAO,8BAA6BS,GAAA,CAAIK,MAAO,GAAE;MAC7D;IACF,EAAE,OAAOK,GAAA,EAAK;MACZ/B,OAAA,CAAQgC,IAAI,CAAE,4BAA2Bd,GAAI,EAAC,EAAEa,GAAA;IAClD;EACF;EAEA,MAAaH,IACXK,GAAW,EACXnD,GAMC,EACD;IACA,MAAM;MAAEoD,IAAI;MAAEC,QAAQ;MAAEC,UAAU;MAAEC,QAAQ;MAAEC;IAAQ,CAAE,GAAGxD,GAAA;IAE3D,IAAI,CAACsD,UAAA,EAAY,OAAO;IAExB,IAAIjB,IAAA,CAAKC,GAAG,KAAK/C,gBAAA,EAAkB;MACjC,IAAI,IAAI,CAACe,KAAK,EAAE;QACdY,OAAA,CAAQC,GAAG,CAAC;MACd;MACA,OAAO;IACT;IAEA,IAAIY,IAAA,GAAOvC,WAAA,oBAAAA,WAAA,CAAasD,GAAG,CAACK,GAAA;IAE5B;IACA;IACA,IAAId,IAAA,CAAKC,GAAG,MAAM,CAAAP,IAAA,oBAAAA,IAAA,CAAM0B,YAAY,KAAI,KAAK,MAAM;MACjD1B,IAAA,GAAO2B,SAAA;IACT;IAEA;IACA,IAAI,CAAC3B,IAAA,IAAQ,IAAI,CAACd,aAAa,EAAE;MAC/B,IAAI;QACF,MAAM0C,KAAA,GAAQtB,IAAA,CAAKC,GAAG;QACtB,MAAMsB,WAAA,GAAoC;UACxCjB,QAAA,EAAU;UACVkB,SAAA,EAAW;UACXL,QAAA,EAAUA,QAAA;UACVD;QACF;QACA,MAAMhB,GAAA,GAAM,MAAMC,KAAA,CACf,GAAE,IAAI,CAACvB,aAAc,sBAAqBkC,GAAI,EAAC,EAChD;UACEV,MAAA,EAAQ;UACRjC,OAAA,EAAS;YACP,GAAG,IAAI,CAACA,OAAO;YACf,CAACX,sBAAA,GAAyB2D,QAAA;YAC1B,CAAC/D,iBAAA,GAAoB,CAAA2D,IAAA,oBAAAA,IAAA,CAAMU,IAAI,CAAC,SAAQ;YACxC,CAACC,UAAA,CAAAC,2BAA2B,GAAG,CAAAX,QAAA,oBAAAA,QAAA,CAAUS,IAAI,CAAC,SAAQ;UACxD;UACApB,IAAA,EAAMkB;QACR;QAGF,IAAIrB,GAAA,CAAIK,MAAM,KAAK,KAAK;UACtB,MAAMC,UAAA,GAAaN,GAAA,CAAI/B,OAAO,CAACsC,GAAG,CAAC,kBAAkB;UACrDvD,gBAAA,GAAmB8C,IAAA,CAAKC,GAAG,KAAKS,QAAA,CAASF,UAAA;QAC3C;QAEA,IAAIN,GAAA,CAAIK,MAAM,KAAK,KAAK;UACtB,IAAI,IAAI,CAACtC,KAAK,EAAE;YACdY,OAAA,CAAQC,GAAG,CACR,4BAA2BgC,GAAI,eAC9Bd,IAAA,CAAKC,GAAG,KAAKqB,KACd,IAAG;UAER;UACA,OAAO;QACT;QAEA,IAAI,CAACpB,GAAA,CAAIS,EAAE,EAAE;UACX9B,OAAA,CAAQ+C,KAAK,CAAC,MAAM1B,GAAA,CAAI2B,IAAI;UAC5B,MAAM,IAAIpC,KAAA,CAAO,+BAA8BS,GAAA,CAAIK,MAAO,EAAC;QAC7D;QAEA,MAAMuB,MAAA,GAAS,MAAM5B,GAAA,CAAI6B,IAAI;QAE7B,IAAI,CAACD,MAAA,IAAUA,MAAA,CAAOxC,IAAI,KAAK,SAAS;UACtC,IAAI,CAACrB,KAAK,IAAIY,OAAA,CAAQC,GAAG,CAAC;YAAEgD;UAAO;UACnC,MAAM,IAAIrC,KAAA,CAAO,qBAAoB;QACvC;QAEA,MAAMuC,UAAA,GAAa9B,GAAA,CAAI/B,OAAO,CAACsC,GAAG,CAACnD,kBAAA;QACnC,MAAM2E,GAAA,GAAM/B,GAAA,CAAI/B,OAAO,CAACsC,GAAG,CAAC;QAE5Bf,IAAA,GAAO;UACLN,KAAA,EAAO0C,MAAA;UACP;UACA;UACAV,YAAA,EACEY,UAAA,KAAe,UACXhC,IAAA,CAAKC,GAAG,KAAKyB,UAAA,CAAAQ,cAAc,GAC3BlC,IAAA,CAAKC,GAAG,KAAKS,QAAA,CAASuB,GAAA,IAAO,KAAK,MAAM;QAChD;QAEA,IAAI,IAAI,CAAChE,KAAK,EAAE;UACdY,OAAA,CAAQC,GAAG,CACR,6BAA4BgC,GAAI,eAC/Bd,IAAA,CAAKC,GAAG,KAAKqB,KACd,aACCa,MAAA,CAAOC,IAAI,CAACN,MAAA,EAAQ3C,MACrB,kBAAiB6C,UAAW,UAASjB,IAAA,oBAAAA,IAAA,CAAMU,IAAI,CAC9C,IACA,cAAaT,QAAA,oBAAAA,QAAA,CAAUS,IAAI,CAAC,IAAK,EAAC;QAExC;QAEA,IAAI/B,IAAA,EAAM;UACRvC,WAAA,oBAAAA,WAAA,CAAakF,GAAG,CAACvB,GAAA,EAAKpB,IAAA;QACxB;MACF,EAAE,OAAOkB,GAAA,EAAK;QACZ;QACA,IAAI,IAAI,CAAC3C,KAAK,EAAE;UACdY,OAAA,CAAQ+C,KAAK,CAAE,gCAA+B,EAAEhB,GAAA;QAClD;MACF;IACF;IAEA,OAAOlB,IAAA,IAAQ;EACjB;EAEA,MAAa2C,IACXvB,GAAW,EACXpB,IAAgC,EAChC;IACEuB,UAAU;IACVC,QAAQ;IACRC,QAAQ;IACRJ;EAAI,CAML,EACD;IACA,IAAI,CAACE,UAAA,EAAY;IAEjB,IAAIjB,IAAA,CAAKC,GAAG,KAAK/C,gBAAA,EAAkB;MACjC,IAAI,IAAI,CAACe,KAAK,EAAE;QACdY,OAAA,CAAQC,GAAG,CAAC;MACd;MACA;IACF;IAEA3B,WAAA,oBAAAA,WAAA,CAAakF,GAAG,CAACvB,GAAA,EAAK;MACpB1B,KAAA,EAAOM,IAAA;MACP0B,YAAA,EAAcpB,IAAA,CAAKC,GAAG;IACxB;IAEA,IAAI,IAAI,CAACrB,aAAa,EAAE;MACtB,IAAI;QACF,MAAM0C,KAAA,GAAQtB,IAAA,CAAKC,GAAG;QACtB,IAAIP,IAAA,KAAS,QAAQ,gBAAgBA,IAAA,EAAM;UACzC,IAAI,CAACvB,OAAO,CAACZ,uBAAA,CAAwB,GAAGmC,IAAA,CAAK4C,UAAU,CAACC,QAAQ;QAClE;QACA,IACE,CAAC,IAAI,CAACpE,OAAO,CAACZ,uBAAA,CAAwB,IACtCmC,IAAA,KAAS,QACT,UAAUA,IAAA,EACV;UACA,IAAI,CAACvB,OAAO,CAACV,0BAAA,CAA2B,GACtCiC,IAAA,CAAKA,IAAI,CAACvB,OAAO,CAAC,gBAAgB;QACtC;QACA,MAAMwB,IAAA,GAAOtB,IAAA,CAAKkB,SAAS,CAAC;UAC1B,GAAGG,IAAI;UACP;UACA;UACAqB,IAAA,EAAMM;QACR;QAEA,IAAI,IAAI,CAACpD,KAAK,EAAE;UACdY,OAAA,CAAQC,GAAG,CAAC,aAAagC,GAAA;QAC3B;QACA,MAAMS,WAAA,GAAoC;UACxCjB,QAAA,EAAU;UACVkB,SAAA,EAAW;UACXL,QAAA;UACAD;QACF;QACA,MAAMhB,GAAA,GAAM,MAAMC,KAAA,CACf,GAAE,IAAI,CAACvB,aAAc,sBAAqBkC,GAAI,EAAC,EAChD;UACEV,MAAA,EAAQ;UACRjC,OAAA,EAAS;YACP,GAAG,IAAI,CAACA,OAAO;YACf,CAACX,sBAAA,GAAyB2D,QAAA,IAAY;YACtC,CAAC/D,iBAAA,GAAoB,CAAA2D,IAAA,oBAAAA,IAAA,CAAMU,IAAI,CAAC,SAAQ;UAC1C;UACA9B,IAAA,EAAMA,IAAA;UACNU,IAAA,EAAMkB;QACR;QAGF,IAAIrB,GAAA,CAAIK,MAAM,KAAK,KAAK;UACtB,MAAMC,UAAA,GAAaN,GAAA,CAAI/B,OAAO,CAACsC,GAAG,CAAC,kBAAkB;UACrDvD,gBAAA,GAAmB8C,IAAA,CAAKC,GAAG,KAAKS,QAAA,CAASF,UAAA;QAC3C;QAEA,IAAI,CAACN,GAAA,CAAIS,EAAE,EAAE;UACX,IAAI,CAAC1C,KAAK,IAAIY,OAAA,CAAQC,GAAG,CAAC,MAAMoB,GAAA,CAAI2B,IAAI;UACxC,MAAM,IAAIpC,KAAA,CAAO,oBAAmBS,GAAA,CAAIK,MAAO,EAAC;QAClD;QAEA,IAAI,IAAI,CAACtC,KAAK,EAAE;UACdY,OAAA,CAAQC,GAAG,CACR,uCAAsCgC,GAAI,eACzCd,IAAA,CAAKC,GAAG,KAAKqB,KACd,aAAY3B,IAAA,CAAKR,MAAO,EAAC;QAE9B;MACF,EAAE,OAAOyB,GAAA,EAAK;QACZ;QACA,IAAI,IAAI,CAAC3C,KAAK,EAAE;UACdY,OAAA,CAAQ+C,KAAK,CAAE,8BAA6B,EAAEhB,GAAA;QAChD;MACF;IACF;IACA;EACF;AACF"},"metadata":{},"sourceType":"script","externalDependencies":[]}