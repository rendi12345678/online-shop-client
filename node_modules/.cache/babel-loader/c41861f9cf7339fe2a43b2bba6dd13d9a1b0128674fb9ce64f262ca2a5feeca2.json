{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"I18NProvider\", {\n  enumerable: true,\n  get: function () {\n    return I18NProvider;\n  }\n});\nclass I18NProvider {\n  constructor(config) {\n    var _config_domains;\n    this.config = config;\n    if (!config.locales.length) {\n      throw new Error(\"Invariant: No locales provided\");\n    }\n    this.lowerCaseLocales = config.locales.map(locale => locale.toLowerCase());\n    this.lowerCaseDomains = (_config_domains = config.domains) == null ? void 0 : _config_domains.map(domainLocale => {\n      var _domainLocale_locales;\n      const domain = domainLocale.domain.toLowerCase();\n      return {\n        defaultLocale: domainLocale.defaultLocale.toLowerCase(),\n        hostname: domain.split(\":\", 1)[0],\n        domain,\n        locales: (_domainLocale_locales = domainLocale.locales) == null ? void 0 : _domainLocale_locales.map(locale => locale.toLowerCase()),\n        http: domainLocale.http\n      };\n    });\n  }\n  /**\n  * Detects the domain locale from the hostname and the detected locale if\n  * provided.\n  *\n  * @param hostname The hostname to detect the domain locale from, this must be lowercased.\n  * @param detectedLocale The detected locale to use if the hostname does not match.\n  * @returns The domain locale if found, `undefined` otherwise.\n  */\n  detectDomainLocale(hostname, detectedLocale) {\n    if (!hostname || !this.lowerCaseDomains || !this.config.domains) return;\n    if (detectedLocale) detectedLocale = detectedLocale.toLowerCase();\n    for (let i = 0; i < this.lowerCaseDomains.length; i++) {\n      var\n      // Configuration validation ensures that the locale is not repeated in\n      // other domains locales.\n      _domainLocale_locales;\n      const domainLocale = this.lowerCaseDomains[i];\n      if (\n      // We assume that the hostname is already lowercased.\n      domainLocale.hostname === hostname || ((_domainLocale_locales = domainLocale.locales) == null ? void 0 : _domainLocale_locales.some(locale => locale === detectedLocale))) {\n        return this.config.domains[i];\n      }\n    }\n    return;\n  }\n  /**\n  * Pulls the pre-computed locale and inference results from the query\n  * object.\n  *\n  * @param pathname the pathname that could contain a locale prefix\n  * @param query the query object\n  * @returns the locale analysis result\n  */\n  fromQuery(pathname, query) {\n    const detectedLocale = query.__nextLocale;\n    // If a locale was detected on the query, analyze the pathname to ensure\n    // that the locale matches.\n    if (detectedLocale) {\n      const analysis = this.analyze(pathname);\n      // If the analysis contained a locale we should validate it against the\n      // query and strip it from the pathname.\n      if (analysis.detectedLocale) {\n        if (analysis.detectedLocale !== detectedLocale) {\n          throw new Error(`Invariant: The detected locale does not match the locale in the query. Expected to find '${detectedLocale}' in '${pathname}' but found '${analysis.detectedLocale}'}`);\n        }\n        pathname = analysis.pathname;\n      }\n    }\n    return {\n      pathname,\n      detectedLocale,\n      inferredFromDefault: query.__nextInferredLocaleFromDefault === \"1\"\n    };\n  }\n  /**\n  * Analyzes the pathname for a locale and returns the pathname without it.\n  *\n  * @param pathname The pathname that could contain a locale prefix.\n  * @param options The options to use when matching the locale.\n  * @returns The matched locale and the pathname without the locale prefix\n  *          (if any).\n  */\n  analyze(pathname, options = {}) {\n    let detectedLocale = options.defaultLocale;\n    // By default, we assume that the default locale was inferred if there was\n    // no detected locale.\n    let inferredFromDefault = typeof detectedLocale === \"string\";\n    // The first segment will be empty, because it has a leading `/`. If\n    // there is no further segment, there is no locale (or it's the default).\n    const segments = pathname.split(\"/\", 2);\n    if (!segments[1]) return {\n      detectedLocale,\n      pathname,\n      inferredFromDefault\n    };\n    // The second segment will contain the locale part if any.\n    const segment = segments[1].toLowerCase();\n    // See if the segment matches one of the locales. If it doesn't, there is\n    // no locale (or it's the default).\n    const index = this.lowerCaseLocales.indexOf(segment);\n    if (index < 0) return {\n      detectedLocale,\n      pathname,\n      inferredFromDefault\n    };\n    // Return the case-sensitive locale.\n    detectedLocale = this.config.locales[index];\n    inferredFromDefault = false;\n    // Remove the `/${locale}` part of the pathname.\n    pathname = pathname.slice(detectedLocale.length + 1) || \"/\";\n    return {\n      detectedLocale,\n      pathname,\n      inferredFromDefault\n    };\n  }\n}","map":{"version":3,"names":["I18NProvider","constructor","config","_config_domains","locales","length","Error","lowerCaseLocales","map","locale","toLowerCase","lowerCaseDomains","domains","domainLocale","_domainLocale_locales","domain","defaultLocale","hostname","split","http","detectDomainLocale","detectedLocale","i","some","fromQuery","pathname","query","__nextLocale","analysis","analyze","inferredFromDefault","__nextInferredLocaleFromDefault","options","segments","segment","index","indexOf","slice"],"sources":["../../../../src/server/future/helpers/i18n-provider.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}