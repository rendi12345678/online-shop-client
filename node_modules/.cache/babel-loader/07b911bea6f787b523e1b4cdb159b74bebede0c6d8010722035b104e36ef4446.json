{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"DevRouteMatcherManager\", {\n  enumerable: true,\n  get: function () {\n    return DevRouteMatcherManager;\n  }\n});\nconst _routekind = require(\"../route-kind\");\nconst _defaultroutematchermanager = require(\"./default-route-matcher-manager\");\nconst _path = /*#__PURE__*/_interop_require_default(require(\"../../../shared/lib/isomorphic/path\"));\nconst _log = /*#__PURE__*/_interop_require_wildcard(require(\"../../../build/output/log\"));\nconst _picocolors = require(\"../../../lib/picocolors\");\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nclass DevRouteMatcherManager extends _defaultroutematchermanager.DefaultRouteMatcherManager {\n  constructor(production, ensurer, dir) {\n    super();\n    this.production = production;\n    this.ensurer = ensurer;\n    this.dir = dir;\n  }\n  async test(pathname, options) {\n    // Try to find a match within the developer routes.\n    const match = await super.match(pathname, options);\n    // Return if the match wasn't null. Unlike the implementation of `match`\n    // which uses `matchAll` here, this does not call `ensure` on the match\n    // found via the development matches.\n    return match !== null;\n  }\n  validate(pathname, matcher, options) {\n    const match = super.validate(pathname, matcher, options);\n    // If a match was found, check to see if there were any conflicting app or\n    // pages files.\n    // TODO: maybe expand this to _any_ duplicated routes instead?\n    if (match && matcher.duplicated && matcher.duplicated.some(duplicate => duplicate.definition.kind === _routekind.RouteKind.APP_PAGE || duplicate.definition.kind === _routekind.RouteKind.APP_ROUTE) && matcher.duplicated.some(duplicate => duplicate.definition.kind === _routekind.RouteKind.PAGES || duplicate.definition.kind === _routekind.RouteKind.PAGES_API)) {\n      return null;\n    }\n    return match;\n  }\n  async *matchAll(pathname, options) {\n    // Compile the development routes.\n    // TODO: we may want to only run this during testing, users won't be fast enough to require this many dir scans\n    await super.reload();\n    // Iterate over the development matches to see if one of them match the\n    // request path.\n    for await (const development of super.matchAll(pathname, options)) {\n      // We're here, which means that we haven't seen this match yet, so we\n      // should try to ensure it and recompile the production matcher.\n      await this.ensurer.ensure(development);\n      await this.production.reload();\n      // Iterate over the production matches again, this time we should be able\n      // to match it against the production matcher unless there's an error.\n      for await (const production of this.production.matchAll(pathname, options)) {\n        yield production;\n      }\n    }\n    // We tried direct matching against the pathname and against all the dynamic\n    // paths, so there was no match.\n    return null;\n  }\n  async reload() {\n    // Compile the production routes again.\n    await this.production.reload();\n    // Compile the development routes.\n    await super.reload();\n    // Check for and warn of any duplicates.\n    for (const [pathname, matchers] of Object.entries(this.matchers.duplicates)) {\n      // We only want to warn about matchers resolving to the same path if their\n      // identities are different.\n      const identity = matchers[0].identity;\n      if (matchers.slice(1).some(matcher => matcher.identity !== identity)) {\n        continue;\n      }\n      _log.warn(`Duplicate page detected. ${matchers.map(matcher => (0, _picocolors.cyan)(_path.default.relative(this.dir, matcher.definition.filename))).join(\" and \")} resolve to ${(0, _picocolors.cyan)(pathname)}`);\n    }\n  }\n}","map":{"version":3,"names":["DevRouteMatcherManager","_defaultroutematchermanager","DefaultRouteMatcherManager","constructor","production","ensurer","dir","test","pathname","options","match","validate","matcher","duplicated","some","duplicate","definition","kind","_routekind","RouteKind","APP_PAGE","APP_ROUTE","PAGES","PAGES_API","matchAll","reload","development","ensure","matchers","Object","entries","duplicates","identity","slice","_log","warn","map","_picocolors","cyan","_path","default","relative","filename","join"],"sources":["../../../../src/server/future/route-matcher-managers/dev-route-matcher-manager.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}