{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  getMetadata: null,\n  processBuffer: null,\n  decodeBuffer: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  getMetadata: function () {\n    return getMetadata;\n  },\n  processBuffer: function () {\n    return processBuffer;\n  },\n  decodeBuffer: function () {\n    return decodeBuffer;\n  }\n});\nconst _jestworker = require(\"next/dist/compiled/jest-worker\");\nconst _path = /*#__PURE__*/_interop_require_wildcard(require(\"path\"));\nconst _utils = require(\"../../../shared/lib/utils\");\nconst _os = require(\"os\");\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interop_require_wildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nconst getWorker = (0, _utils.execOnce)(() => new _jestworker.Worker(_path.resolve(__dirname, \"impl\"), {\n  enableWorkerThreads: true,\n  // There will be at most 6 workers needed since each worker will take\n  // at least 1 operation type.\n  numWorkers: Math.max(1, Math.min((0, _os.cpus)().length - 1, 6)),\n  computeWorkerKey: method => method\n}));\nasync function getMetadata(buffer) {\n  const worker = getWorker();\n  const {\n    width,\n    height\n  } = await worker.decodeBuffer(buffer);\n  return {\n    width,\n    height\n  };\n}\nasync function processBuffer(buffer, operations, encoding, quality) {\n  const worker = getWorker();\n  let imageData = await worker.decodeBuffer(buffer);\n  for (const operation of operations) {\n    if (operation.type === \"rotate\") {\n      imageData = await worker.rotate(imageData, operation.numRotations);\n    } else if (operation.type === \"resize\") {\n      const opt = {\n        image: imageData,\n        width: 0,\n        height: 0\n      };\n      if (operation.width && imageData.width && imageData.width > operation.width) {\n        opt.width = operation.width;\n      }\n      if (operation.height && imageData.height && imageData.height > operation.height) {\n        opt.height = operation.height;\n      }\n      if (opt.width > 0 || opt.height > 0) {\n        imageData = await worker.resize(opt);\n      }\n    }\n  }\n  switch (encoding) {\n    case \"jpeg\":\n      return Buffer.from(await worker.encodeJpeg(imageData, {\n        quality\n      }));\n    case \"webp\":\n      return Buffer.from(await worker.encodeWebp(imageData, {\n        quality\n      }));\n    case \"avif\":\n      const avifQuality = quality - 20;\n      return Buffer.from(await worker.encodeAvif(imageData, {\n        quality: Math.max(avifQuality, 0)\n      }));\n    case \"png\":\n      return Buffer.from(await worker.encodePng(imageData));\n    default:\n      throw Error(`Unsupported encoding format`);\n  }\n}\nasync function decodeBuffer(buffer) {\n  const worker = getWorker();\n  const imageData = await worker.decodeBuffer(buffer);\n  return imageData;\n}","map":{"version":3,"names":["getMetadata","processBuffer","decodeBuffer","getWorker","_utils","execOnce","_jestworker","Worker","_path","resolve","__dirname","enableWorkerThreads","numWorkers","Math","max","min","_os","cpus","length","computeWorkerKey","method","buffer","worker","width","height","operations","encoding","quality","imageData","operation","type","rotate","numRotations","opt","image","resize","Buffer","from","encodeJpeg","encodeWebp","avifQuality","encodeAvif","encodePng","Error"],"sources":["../../../../src/server/lib/squoosh/main.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}