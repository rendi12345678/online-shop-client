{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"DefaultRouteMatcherManager\", {\n  enumerable: true,\n  get: function () {\n    return DefaultRouteMatcherManager;\n  }\n});\nconst _utils = require(\"../../../shared/lib/router/utils\");\nconst _localeroutematcher = require(\"../route-matchers/locale-route-matcher\");\nconst _ensureleadingslash = require(\"../../../shared/lib/page-path/ensure-leading-slash\");\nconst _detachedpromise = require(\"../../../lib/detached-promise\");\nclass DefaultRouteMatcherManager {\n  /**\n  * When this value changes, it indicates that a change has been introduced\n  * that requires recompilation.\n  */\n  get compilationID() {\n    return this.providers.length;\n  }\n  async waitTillReady() {\n    if (this.waitTillReadyPromise) {\n      await this.waitTillReadyPromise;\n      delete this.waitTillReadyPromise;\n    }\n  }\n  async reload() {\n    const {\n      promise,\n      resolve,\n      reject\n    } = new _detachedpromise.DetachedPromise();\n    this.waitTillReadyPromise = promise;\n    // Grab the compilation ID for this run, we'll verify it at the end to\n    // ensure that if any routes were added before reloading is finished that\n    // we error out.\n    const compilationID = this.compilationID;\n    try {\n      // Collect all the matchers from each provider.\n      const matchers = [];\n      // Get all the providers matchers.\n      const providersMatchers = await Promise.all(this.providers.map(provider => provider.matchers()));\n      // Use this to detect duplicate pathnames.\n      const all = new Map();\n      const duplicates = {};\n      for (const providerMatchers of providersMatchers) {\n        for (const matcher of providerMatchers) {\n          // Reset duplicated matches when reloading from pages conflicting state.\n          if (matcher.duplicated) delete matcher.duplicated;\n          // Test to see if the matcher being added is a duplicate.\n          const duplicate = all.get(matcher.definition.pathname);\n          if (duplicate) {\n            // This looks a little weird, but essentially if the pathname\n            // already exists in the duplicates map, then we got that array\n            // reference. Otherwise, we create a new array with the original\n            // duplicate first. Then we push the new matcher into the duplicate\n            // array, and reset it to the duplicates object (which may be a\n            // no-op if the pathname already existed in the duplicates object).\n            // Then we set the array of duplicates on both the original\n            // duplicate object and the new one, so we can keep them in sync.\n            // If a new duplicate is found, and it matches an existing pathname,\n            // the retrieval of the `other` will actually return the array\n            // reference used by all other duplicates. This is why ReadonlyArray\n            // is so important! Array's are always references!\n            const others = duplicates[matcher.definition.pathname] ?? [duplicate];\n            others.push(matcher);\n            duplicates[matcher.definition.pathname] = others;\n            // Add duplicated details to each route.\n            duplicate.duplicated = others;\n            matcher.duplicated = others;\n            // TODO: see if we should error for duplicates in production?\n          }\n\n          matchers.push(matcher);\n          // Add the matcher's pathname to the set.\n          all.set(matcher.definition.pathname, matcher);\n        }\n      }\n      // Update the duplicate matchers. This is used in the development manager\n      // to warn about duplicates.\n      this.matchers.duplicates = duplicates;\n      // If the cache is the same as what we just parsed, we can exit now. We\n      // can tell by using the `===` which compares object identity, which for\n      // the manifest matchers, will return the same matcher each time.\n      if (this.previousMatchers.length === matchers.length && this.previousMatchers.every((cachedMatcher, index) => cachedMatcher === matchers[index])) {\n        return;\n      }\n      this.previousMatchers = matchers;\n      // For matchers that are for static routes, filter them now.\n      this.matchers.static = matchers.filter(matcher => !matcher.isDynamic);\n      // For matchers that are for dynamic routes, filter them and sort them now.\n      const dynamic = matchers.filter(matcher => matcher.isDynamic);\n      // As `getSortedRoutes` only takes an array of strings, we need to create\n      // a map of the pathnames (used for sorting) and the matchers. When we\n      // have locales, there may be multiple matches for the same pathname. To\n      // handle this, we keep a map of all the indexes (in `reference`) and\n      // merge them in later.\n      const reference = new Map();\n      const pathnames = new Array();\n      for (let index = 0; index < dynamic.length; index++) {\n        // Grab the pathname from the definition.\n        const pathname = dynamic[index].definition.pathname;\n        // Grab the index in the dynamic array, push it into the reference.\n        const indexes = reference.get(pathname) ?? [];\n        indexes.push(index);\n        // If this is the first one set it. If it isn't, we don't need to\n        // because pushing above on the array will mutate the array already\n        // stored there because array's are always a reference!\n        if (indexes.length === 1) reference.set(pathname, indexes);else continue;\n        pathnames.push(pathname);\n      }\n      // Sort the array of pathnames.\n      const sorted = (0, _utils.getSortedRoutes)(pathnames);\n      // For each of the sorted pathnames, iterate over them, grabbing the list\n      // of indexes and merging them back into the new `sortedDynamicMatchers`\n      // array. The order of the same matching pathname doesn't matter because\n      // they will have other matching characteristics (like the locale) that\n      // is considered.\n      const sortedDynamicMatchers = [];\n      for (const pathname of sorted) {\n        const indexes = reference.get(pathname);\n        if (!Array.isArray(indexes)) {\n          throw new Error(\"Invariant: expected to find identity in indexes map\");\n        }\n        const dynamicMatches = indexes.map(index => dynamic[index]);\n        sortedDynamicMatchers.push(...dynamicMatches);\n      }\n      this.matchers.dynamic = sortedDynamicMatchers;\n      // This means that there was a new matcher pushed while we were waiting\n      if (this.compilationID !== compilationID) {\n        throw new Error(\"Invariant: expected compilation to finish before new matchers were added, possible missing await\");\n      }\n    } catch (err) {\n      reject(err);\n    } finally {\n      // The compilation ID matched, so mark the complication as finished.\n      this.lastCompilationID = compilationID;\n      resolve();\n    }\n  }\n  push(provider) {\n    this.providers.push(provider);\n  }\n  async test(pathname, options) {\n    // See if there's a match for the pathname...\n    const match = await this.match(pathname, options);\n    // This default implementation only needs to check to see if there _was_ a\n    // match. The development matcher actually changes it's behavior by not\n    // recompiling the routes.\n    return match !== null;\n  }\n  async match(pathname, options) {\n    // \"Iterate\" over the match options. Once we found a single match, exit with\n    // it, otherwise return null below. If no match is found, the inner block\n    // won't be called.\n    for await (const match of this.matchAll(pathname, options)) {\n      return match;\n    }\n    return null;\n  }\n  /**\n  * This is a point for other managers to override to inject other checking\n  * behavior like duplicate route checking on a per-request basis.\n  *\n  * @param pathname the pathname to validate against\n  * @param matcher the matcher to validate/test with\n  * @returns the match if found\n  */\n  validate(pathname, matcher, options) {\n    var _options_i18n;\n    if (matcher instanceof _localeroutematcher.LocaleRouteMatcher) {\n      return matcher.match(pathname, options);\n    }\n    // If the locale was inferred from the default locale, then it will have\n    // already added a locale to the pathname. We need to remove it before\n    // matching because this matcher is not locale aware.\n    if ((_options_i18n = options.i18n) == null ? void 0 : _options_i18n.inferredFromDefault) {\n      return matcher.match(options.i18n.pathname);\n    }\n    return matcher.match(pathname);\n  }\n  async *matchAll(pathname, options) {\n    // Guard against the matcher manager from being run before it needs to be\n    // recompiled. This was preferred to re-running the compilation here because\n    // it should be re-ran only when it changes. If a match is attempted before\n    // this is done, it indicates that there is a case where a provider is added\n    // before it was recompiled (an error). We also don't want to affect request\n    // times.\n    if (this.lastCompilationID !== this.compilationID) {\n      throw new Error(\"Invariant: expected routes to have been loaded before match\");\n    }\n    // Ensure that path matching is done with a leading slash.\n    pathname = (0, _ensureleadingslash.ensureLeadingSlash)(pathname);\n    // If this pathname doesn't look like a dynamic route, and this pathname is\n    // listed in the normalized list of routes, then return it. This ensures\n    // that when a route like `/user/[id]` is encountered, it doesn't just match\n    // with the list of normalized routes.\n    if (!(0, _utils.isDynamicRoute)(pathname)) {\n      for (const matcher of this.matchers.static) {\n        const match = this.validate(pathname, matcher, options);\n        if (!match) continue;\n        yield match;\n      }\n    }\n    // If we should skip handling dynamic routes, exit now.\n    if (options == null ? void 0 : options.skipDynamic) return null;\n    // Loop over the dynamic matchers, yielding each match.\n    for (const matcher of this.matchers.dynamic) {\n      const match = this.validate(pathname, matcher, options);\n      if (!match) continue;\n      yield match;\n    }\n    // We tried direct matching against the pathname and against all the dynamic\n    // paths, so there was no match.\n    return null;\n  }\n  constructor() {\n    this.providers = [];\n    this.matchers = {\n      static: [],\n      dynamic: [],\n      duplicates: {}\n    };\n    this.lastCompilationID = this.compilationID;\n    this.previousMatchers = [];\n  }\n}","map":{"version":3,"names":["DefaultRouteMatcherManager","compilationID","providers","length","waitTillReady","waitTillReadyPromise","reload","promise","resolve","reject","_detachedpromise","DetachedPromise","matchers","providersMatchers","Promise","all","map","provider","Map","duplicates","providerMatchers","matcher","duplicated","duplicate","get","definition","pathname","others","push","set","previousMatchers","every","cachedMatcher","index","static","filter","isDynamic","dynamic","reference","pathnames","Array","indexes","sorted","_utils","getSortedRoutes","sortedDynamicMatchers","isArray","Error","dynamicMatches","err","lastCompilationID","test","options","match","matchAll","validate","_options_i18n","_localeroutematcher","LocaleRouteMatcher","i18n","inferredFromDefault","_ensureleadingslash","ensureLeadingSlash","isDynamicRoute","skipDynamic"],"sources":["../../../../src/server/future/route-matcher-managers/default-route-matcher-manager.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}