{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  getTracer: null,\n  SpanStatusCode: null,\n  SpanKind: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  getTracer: function () {\n    return getTracer;\n  },\n  SpanStatusCode: function () {\n    return SpanStatusCode;\n  },\n  SpanKind: function () {\n    return SpanKind;\n  }\n});\nconst _constants = require(\"./constants\");\nlet api;\n// we want to allow users to use their own version of @opentelemetry/api if they\n// want to, so we try to require it first, and if it fails we fall back to the\n// version that is bundled with Next.js\n// this is because @opentelemetry/api has to be synced with the version of\n// @opentelemetry/tracing that is used, and we don't want to force users to use\n// the version that is bundled with Next.js.\n// the API is ~stable, so this should be fine\nif (process.env.NEXT_RUNTIME === \"edge\") {\n  api = require(\"@opentelemetry/api\");\n} else {\n  try {\n    api = require(\"@opentelemetry/api\");\n  } catch (err) {\n    api = require(\"next/dist/compiled/@opentelemetry/api\");\n  }\n}\nconst {\n  context,\n  propagation,\n  trace,\n  SpanStatusCode,\n  SpanKind,\n  ROOT_CONTEXT\n} = api;\nconst isPromise = p => {\n  return p !== null && typeof p === \"object\" && typeof p.then === \"function\";\n};\nconst closeSpanWithError = (span, error) => {\n  if ((error == null ? void 0 : error.bubble) === true) {\n    span.setAttribute(\"next.bubble\", true);\n  } else {\n    if (error) {\n      span.recordException(error);\n    }\n    span.setStatus({\n      code: SpanStatusCode.ERROR,\n      message: error == null ? void 0 : error.message\n    });\n  }\n  span.end();\n};\n/** we use this map to propagate attributes from nested spans to the top span */\nconst rootSpanAttributesStore = new Map();\nconst rootSpanIdKey = api.createContextKey(\"next.rootSpanId\");\nlet lastSpanId = 0;\nconst getSpanId = () => lastSpanId++;\nclass NextTracerImpl {\n  /**\n  * Returns an instance to the trace with configured name.\n  * Since wrap / trace can be defined in any place prior to actual trace subscriber initialization,\n  * This should be lazily evaluated.\n  */\n  getTracerInstance() {\n    return trace.getTracer(\"next.js\", \"0.0.1\");\n  }\n  getContext() {\n    return context;\n  }\n  getActiveScopeSpan() {\n    return trace.getSpan(context == null ? void 0 : context.active());\n  }\n  withPropagatedContext(req, fn) {\n    if (context.active() !== ROOT_CONTEXT) {\n      return fn();\n    }\n    const remoteContext = propagation.extract(ROOT_CONTEXT, req.headers);\n    return context.with(remoteContext, fn);\n  }\n  trace(...args) {\n    var _trace_getSpanContext;\n    const [type, fnOrOptions, fnOrEmpty] = args;\n    // coerce options form overload\n    const {\n      fn,\n      options\n    } = typeof fnOrOptions === \"function\" ? {\n      fn: fnOrOptions,\n      options: {}\n    } : {\n      fn: fnOrEmpty,\n      options: {\n        ...fnOrOptions\n      }\n    };\n    if (!_constants.NextVanillaSpanAllowlist.includes(type) && process.env.NEXT_OTEL_VERBOSE !== \"1\" || options.hideSpan) {\n      return fn();\n    }\n    const spanName = options.spanName ?? type;\n    // Trying to get active scoped span to assign parent. If option specifies parent span manually, will try to use it.\n    let spanContext = this.getSpanContext((options == null ? void 0 : options.parentSpan) ?? this.getActiveScopeSpan());\n    let isRootSpan = false;\n    if (!spanContext) {\n      spanContext = ROOT_CONTEXT;\n      isRootSpan = true;\n    } else if ((_trace_getSpanContext = trace.getSpanContext(spanContext)) == null ? void 0 : _trace_getSpanContext.isRemote) {\n      isRootSpan = true;\n    }\n    const spanId = getSpanId();\n    options.attributes = {\n      \"next.span_name\": spanName,\n      \"next.span_type\": type,\n      ...options.attributes\n    };\n    return context.with(spanContext.setValue(rootSpanIdKey, spanId), () => this.getTracerInstance().startActiveSpan(spanName, options, span => {\n      const onCleanup = () => {\n        rootSpanAttributesStore.delete(spanId);\n      };\n      if (isRootSpan) {\n        rootSpanAttributesStore.set(spanId, new Map(Object.entries(options.attributes ?? {})));\n      }\n      try {\n        if (fn.length > 1) {\n          return fn(span, err => closeSpanWithError(span, err));\n        }\n        const result = fn(span);\n        if (isPromise(result)) {\n          result.then(() => span.end(), err => closeSpanWithError(span, err)).finally(onCleanup);\n        } else {\n          span.end();\n          onCleanup();\n        }\n        return result;\n      } catch (err) {\n        closeSpanWithError(span, err);\n        onCleanup();\n        throw err;\n      }\n    }));\n  }\n  wrap(...args) {\n    const tracer = this;\n    const [name, options, fn] = args.length === 3 ? args : [args[0], {}, args[1]];\n    if (!_constants.NextVanillaSpanAllowlist.includes(name) && process.env.NEXT_OTEL_VERBOSE !== \"1\") {\n      return fn;\n    }\n    return function () {\n      let optionsObj = options;\n      if (typeof optionsObj === \"function\" && typeof fn === \"function\") {\n        optionsObj = optionsObj.apply(this, arguments);\n      }\n      const lastArgId = arguments.length - 1;\n      const cb = arguments[lastArgId];\n      if (typeof cb === \"function\") {\n        const scopeBoundCb = tracer.getContext().bind(context.active(), cb);\n        return tracer.trace(name, optionsObj, (_span, done) => {\n          arguments[lastArgId] = function (err) {\n            done == null ? void 0 : done(err);\n            return scopeBoundCb.apply(this, arguments);\n          };\n          return fn.apply(this, arguments);\n        });\n      } else {\n        return tracer.trace(name, optionsObj, () => fn.apply(this, arguments));\n      }\n    };\n  }\n  startSpan(...args) {\n    const [type, options] = args;\n    const spanContext = this.getSpanContext((options == null ? void 0 : options.parentSpan) ?? this.getActiveScopeSpan());\n    return this.getTracerInstance().startSpan(type, options, spanContext);\n  }\n  getSpanContext(parentSpan) {\n    const spanContext = parentSpan ? trace.setSpan(context.active(), parentSpan) : undefined;\n    return spanContext;\n  }\n  getRootSpanAttributes() {\n    const spanId = context.active().getValue(rootSpanIdKey);\n    return rootSpanAttributesStore.get(spanId);\n  }\n}\nconst getTracer = (() => {\n  const tracer = new NextTracerImpl();\n  return () => tracer;\n})();","map":{"version":3,"names":["getTracer","SpanStatusCode","SpanKind","api","process","env","NEXT_RUNTIME","require","err","context","propagation","trace","ROOT_CONTEXT","isPromise","p","then","closeSpanWithError","span","error","bubble","setAttribute","recordException","setStatus","code","ERROR","message","end","rootSpanAttributesStore","Map","rootSpanIdKey","createContextKey","lastSpanId","getSpanId","NextTracerImpl","getTracerInstance","getContext","getActiveScopeSpan","getSpan","active","withPropagatedContext","req","fn","remoteContext","extract","headers","with","args","_trace_getSpanContext","type","fnOrOptions","fnOrEmpty","options","_constants","NextVanillaSpanAllowlist","includes","NEXT_OTEL_VERBOSE","hideSpan","spanName","spanContext","getSpanContext","parentSpan","isRootSpan","isRemote","spanId","attributes","setValue","startActiveSpan","onCleanup","delete","set","Object","entries","length","result","finally","wrap","tracer","name","optionsObj","apply","arguments","lastArgId","cb","scopeBoundCb","bind","_span","done","startSpan","setSpan","undefined","getRootSpanAttributes","getValue","get"],"sources":["../../../../src/server/lib/trace/tracer.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}