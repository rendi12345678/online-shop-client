{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: function () {\n    return ResponseCache;\n  }\n});\n0 && __export(require(\"./types\"));\nconst _renderresult = /*#__PURE__*/_interop_require_default(require(\"../render-result\"));\nconst _batcher = require(\"../../lib/batcher\");\nconst _scheduler = require(\"../../lib/scheduler\");\n_export_star(require(\"./types\"), exports);\nfunction _export_star(from, to) {\n  Object.keys(from).forEach(function (k) {\n    if (k !== \"default\" && !Object.prototype.hasOwnProperty.call(to, k)) {\n      Object.defineProperty(to, k, {\n        enumerable: true,\n        get: function () {\n          return from[k];\n        }\n      });\n    }\n  });\n  return from;\n}\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nclass ResponseCache {\n  constructor(minimalMode) {\n    this.batcher = _batcher.Batcher.create({\n      // Ensure on-demand revalidate doesn't block normal requests, it should be\n      // safe to run an on-demand revalidate for the same key as a normal request.\n      cacheKeyFn: ({\n        key,\n        isOnDemandRevalidate\n      }) => `${key}-${isOnDemandRevalidate ? \"1\" : \"0\"}`,\n      // We wait to do any async work until after we've added our promise to\n      // `pendingResponses` to ensure that any any other calls will reuse the\n      // same promise until we've fully finished our work.\n      schedulerFn: _scheduler.scheduleOnNextTick\n    });\n    // this is a hack to avoid Webpack knowing this is equal to this.minimalMode\n    // because we replace this.minimalMode to true in production bundles.\n    const minimalModeKey = \"minimalMode\";\n    this[minimalModeKey] = minimalMode;\n  }\n  get(key, responseGenerator, context) {\n    // If there is no key for the cache, we can't possibly look this up in the\n    // cache so just return the result of the response generator.\n    if (!key) return responseGenerator(false, null);\n    const {\n      incrementalCache,\n      isOnDemandRevalidate = false\n    } = context;\n    return this.batcher.batch({\n      key,\n      isOnDemandRevalidate\n    }, async (cacheKey, resolve) => {\n      var _this_previousCacheItem;\n      // We keep the previous cache entry around to leverage when the\n      // incremental cache is disabled in minimal mode.\n      if (this.minimalMode && ((_this_previousCacheItem = this.previousCacheItem) == null ? void 0 : _this_previousCacheItem.key) === cacheKey && this.previousCacheItem.expiresAt > Date.now()) {\n        return this.previousCacheItem.entry;\n      }\n      let resolved = false;\n      let cachedResponse = null;\n      try {\n        cachedResponse = !this.minimalMode ? await incrementalCache.get(key) : null;\n        if (cachedResponse && !isOnDemandRevalidate) {\n          var _cachedResponse_value, _cachedResponse_value1;\n          if (((_cachedResponse_value = cachedResponse.value) == null ? void 0 : _cachedResponse_value.kind) === \"FETCH\") {\n            throw new Error(`invariant: unexpected cachedResponse of kind fetch in response cache`);\n          }\n          resolve({\n            isStale: cachedResponse.isStale,\n            revalidate: cachedResponse.curRevalidate,\n            value: ((_cachedResponse_value1 = cachedResponse.value) == null ? void 0 : _cachedResponse_value1.kind) === \"PAGE\" ? {\n              kind: \"PAGE\",\n              html: _renderresult.default.fromStatic(cachedResponse.value.html),\n              pageData: cachedResponse.value.pageData,\n              postponed: cachedResponse.value.postponed,\n              headers: cachedResponse.value.headers,\n              status: cachedResponse.value.status\n            } : cachedResponse.value\n          });\n          resolved = true;\n          if (!cachedResponse.isStale || context.isPrefetch) {\n            // The cached value is still valid, so we don't need\n            // to update it yet.\n            return null;\n          }\n        }\n        const cacheEntry = await responseGenerator(resolved, cachedResponse);\n        const resolveValue = cacheEntry === null ? null : {\n          ...cacheEntry,\n          isMiss: !cachedResponse\n        };\n        // For on-demand revalidate wait to resolve until cache is set.\n        // Otherwise resolve now.\n        if (!isOnDemandRevalidate && !resolved) {\n          resolve(resolveValue);\n          resolved = true;\n        }\n        if (cacheEntry && typeof cacheEntry.revalidate !== \"undefined\") {\n          if (this.minimalMode) {\n            this.previousCacheItem = {\n              key: cacheKey,\n              entry: cacheEntry,\n              expiresAt: Date.now() + 1000\n            };\n          } else {\n            var _cacheEntry_value;\n            await incrementalCache.set(key, ((_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) === \"PAGE\" ? {\n              kind: \"PAGE\",\n              html: cacheEntry.value.html.toUnchunkedString(),\n              postponed: cacheEntry.value.postponed,\n              pageData: cacheEntry.value.pageData,\n              headers: cacheEntry.value.headers,\n              status: cacheEntry.value.status\n            } : cacheEntry.value, {\n              revalidate: cacheEntry.revalidate\n            });\n          }\n        } else {\n          this.previousCacheItem = undefined;\n        }\n        return resolveValue;\n      } catch (err) {\n        // When a getStaticProps path is erroring we automatically re-set the\n        // existing cache under a new expiration to prevent non-stop retrying.\n        if (cachedResponse) {\n          await incrementalCache.set(key, cachedResponse.value, {\n            revalidate: Math.min(Math.max(cachedResponse.revalidate || 3, 3), 30)\n          });\n        }\n        // While revalidating in the background we can't reject as we already\n        // resolved the cache entry so log the error here.\n        if (resolved) {\n          console.error(err);\n          return null;\n        }\n        // We haven't resolved yet, so let's throw to indicate an error.\n        throw err;\n      }\n    });\n  }\n}","map":{"version":3,"names":["ResponseCache","exports","constructor","minimalMode","batcher","_batcher","Batcher","create","cacheKeyFn","key","isOnDemandRevalidate","schedulerFn","_scheduler","scheduleOnNextTick","minimalModeKey","get","responseGenerator","context","incrementalCache","batch","cacheKey","resolve","_this_previousCacheItem","previousCacheItem","expiresAt","Date","now","entry","resolved","cachedResponse","_cachedResponse_value","_cachedResponse_value1","value","kind","Error","isStale","revalidate","curRevalidate","html","_renderresult","default","fromStatic","pageData","postponed","headers","status","isPrefetch","cacheEntry","resolveValue","isMiss","_cacheEntry_value","set","toUnchunkedString","undefined","err","Math","min","max","console","error"],"sources":["../../../src/server/response-cache/index.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}