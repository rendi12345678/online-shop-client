{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  isAbortError: null,\n  pipeToNodeResponse: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  isAbortError: function () {\n    return isAbortError;\n  },\n  pipeToNodeResponse: function () {\n    return pipeToNodeResponse;\n  }\n});\nconst _nextrequest = require(\"./web/spec-extension/adapters/next-request\");\nconst _detachedpromise = require(\"../lib/detached-promise\");\nfunction isAbortError(e) {\n  return (e == null ? void 0 : e.name) === \"AbortError\" || (e == null ? void 0 : e.name) === _nextrequest.ResponseAbortedName;\n}\nfunction createWriterFromResponse(res) {\n  let started = false;\n  // Create a promise that will resolve once the response has drained. See\n  // https://nodejs.org/api/stream.html#stream_event_drain\n  let drained = new _detachedpromise.DetachedPromise();\n  function onDrain() {\n    drained.resolve();\n  }\n  res.on(\"drain\", onDrain);\n  // If the finish event fires, it means we shouldn't block and wait for the\n  // drain event.\n  res.once(\"close\", () => {\n    res.off(\"drain\", onDrain);\n    drained.resolve();\n  });\n  // Create a promise that will resolve once the response has finished. See\n  // https://nodejs.org/api/http.html#event-finish_1\n  const finished = new _detachedpromise.DetachedPromise();\n  res.once(\"finish\", () => {\n    finished.resolve();\n  });\n  // Create a writable stream that will write to the response.\n  return new WritableStream({\n    write: async chunk => {\n      // You'd think we'd want to use `start` instead of placing this in `write`\n      // but this ensures that we don't actually flush the headers until we've\n      // started writing chunks.\n      if (!started) {\n        started = true;\n        res.flushHeaders();\n      }\n      try {\n        const ok = res.write(chunk);\n        // Added by the `compression` middleware, this is a function that will\n        // flush the partially-compressed response to the client.\n        if (\"flush\" in res && typeof res.flush === \"function\") {\n          res.flush();\n        }\n        // If the write returns false, it means there's some backpressure, so\n        // wait until it's streamed before continuing.\n        if (!ok) {\n          await drained.promise;\n          // Reset the drained promise so that we can wait for the next drain event.\n          drained = new _detachedpromise.DetachedPromise();\n        }\n      } catch (err) {\n        res.end();\n        throw new Error(\"failed to write chunk to response\", {\n          cause: err\n        });\n      }\n    },\n    abort: err => {\n      if (res.writableFinished) return;\n      res.destroy(err);\n    },\n    close: () => {\n      if (res.writableFinished) return;\n      res.end();\n      return finished.promise;\n    }\n  });\n}\nasync function pipeToNodeResponse(readable, res) {\n  try {\n    // If the response has already errored, then just return now.\n    const {\n      errored,\n      destroyed\n    } = res;\n    if (errored || destroyed) return;\n    // Create a new AbortController so that we can abort the readable if the\n    // client disconnects.\n    const controller = (0, _nextrequest.createAbortController)(res);\n    const writer = createWriterFromResponse(res);\n    await readable.pipeTo(writer, {\n      signal: controller.signal\n    });\n  } catch (err) {\n    // If this isn't related to an abort error, re-throw it.\n    if (isAbortError(err)) return;\n    throw new Error(\"failed to pipe response\", {\n      cause: err\n    });\n  }\n}","map":{"version":3,"names":["isAbortError","pipeToNodeResponse","e","name","_nextrequest","ResponseAbortedName","createWriterFromResponse","res","started","drained","_detachedpromise","DetachedPromise","onDrain","resolve","on","once","off","finished","WritableStream","write","chunk","flushHeaders","ok","flush","promise","err","end","Error","cause","abort","writableFinished","destroy","close","readable","errored","destroyed","controller","createAbortController","writer","pipeTo","signal"],"sources":["../../src/server/pipe-readable.ts"],"sourcesContent":[null],"mappings":";;;;;;;;;;;;;;;;EAQgBA,YAAY,WAAAA,CAAA;WAAZA,YAAA;;EA8EMC,kBAAkB,WAAAA,CAAA;WAAlBA,kBAAA;;;6BAjFf;iCACyB;AAEzB,SAASD,aAAaE,CAAM;EACjC,OAAO,CAAAA,CAAA,oBAAAA,CAAA,CAAGC,IAAI,MAAK,gBAAgB,CAAAD,CAAA,oBAAAA,CAAA,CAAGC,IAAI,MAAKC,YAAA,CAAAC,mBAAmB;AACpE;AAEA,SAASC,yBACPC,GAAmB;EAEnB,IAAIC,OAAA,GAAU;EAEd;EACA;EACA,IAAIC,OAAA,GAAU,IAAIC,gBAAA,CAAAC,eAAe;EACjC,SAASC,QAAA;IACPH,OAAA,CAAQI,OAAO;EACjB;EACAN,GAAA,CAAIO,EAAE,CAAC,SAASF,OAAA;EAEhB;EACA;EACAL,GAAA,CAAIQ,IAAI,CAAC,SAAS;IAChBR,GAAA,CAAIS,GAAG,CAAC,SAASJ,OAAA;IACjBH,OAAA,CAAQI,OAAO;EACjB;EAEA;EACA;EACA,MAAMI,QAAA,GAAW,IAAIP,gBAAA,CAAAC,eAAe;EACpCJ,GAAA,CAAIQ,IAAI,CAAC,UAAU;IACjBE,QAAA,CAASJ,OAAO;EAClB;EAEA;EACA,OAAO,IAAIK,cAAA,CAA2B;IACpCC,KAAA,EAAO,MAAOC,KAAA;MACZ;MACA;MACA;MACA,IAAI,CAACZ,OAAA,EAAS;QACZA,OAAA,GAAU;QACVD,GAAA,CAAIc,YAAY;MAClB;MAEA,IAAI;QACF,MAAMC,EAAA,GAAKf,GAAA,CAAIY,KAAK,CAACC,KAAA;QAErB;QACA;QACA,IAAI,WAAWb,GAAA,IAAO,OAAOA,GAAA,CAAIgB,KAAK,KAAK,YAAY;UACrDhB,GAAA,CAAIgB,KAAK;QACX;QAEA;QACA;QACA,IAAI,CAACD,EAAA,EAAI;UACP,MAAMb,OAAA,CAAQe,OAAO;UAErB;UACAf,OAAA,GAAU,IAAIC,gBAAA,CAAAC,eAAe;QAC/B;MACF,EAAE,OAAOc,GAAA,EAAK;QACZlB,GAAA,CAAImB,GAAG;QACP,MAAM,IAAIC,KAAA,CAAM,qCAAqC;UAAEC,KAAA,EAAOH;QAAI;MACpE;IACF;IACAI,KAAA,EAAQJ,GAAA;MACN,IAAIlB,GAAA,CAAIuB,gBAAgB,EAAE;MAE1BvB,GAAA,CAAIwB,OAAO,CAACN,GAAA;IACd;IACAO,KAAA,EAAOA,CAAA;MACL,IAAIzB,GAAA,CAAIuB,gBAAgB,EAAE;MAE1BvB,GAAA,CAAImB,GAAG;MACP,OAAOT,QAAA,CAASO,OAAO;IACzB;EACF;AACF;AAEO,eAAevB,mBACpBgC,QAAoC,EACpC1B,GAAmB;EAEnB,IAAI;IACF;IACA,MAAM;MAAE2B,OAAO;MAAEC;IAAS,CAAE,GAAG5B,GAAA;IAC/B,IAAI2B,OAAA,IAAWC,SAAA,EAAW;IAE1B;IACA;IACA,MAAMC,UAAA,GAAa,IAAAhC,YAAA,CAAAiC,qBAAqB,EAAC9B,GAAA;IAEzC,MAAM+B,MAAA,GAAShC,wBAAA,CAAyBC,GAAA;IAExC,MAAM0B,QAAA,CAASM,MAAM,CAACD,MAAA,EAAQ;MAAEE,MAAA,EAAQJ,UAAA,CAAWI;IAAO;EAC5D,EAAE,OAAOf,GAAA,EAAU;IACjB;IACA,IAAIzB,YAAA,CAAayB,GAAA,GAAM;IAEvB,MAAM,IAAIE,KAAA,CAAM,2BAA2B;MAAEC,KAAA,EAAOH;IAAI;EAC1D;AACF"},"metadata":{},"sourceType":"script","externalDependencies":[]}