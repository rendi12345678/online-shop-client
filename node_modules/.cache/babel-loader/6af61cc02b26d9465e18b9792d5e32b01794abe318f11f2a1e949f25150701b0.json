{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"BatchedFileReader\", {\n  enumerable: true,\n  get: function () {\n    return BatchedFileReader;\n  }\n});\nclass BatchedFileReader {\n  constructor(reader) {\n    this.reader = reader;\n  }\n  schedule(callback) {\n    if (!this.schedulePromise) {\n      this.schedulePromise = Promise.resolve();\n    }\n    this.schedulePromise.then(() => {\n      process.nextTick(callback);\n    });\n  }\n  getOrCreateBatch() {\n    // If there is an existing batch and it's not completed, then reuse it.\n    if (this.batch && !this.batch.completed) {\n      return this.batch;\n    }\n    const batch = {\n      completed: false,\n      directories: [],\n      callbacks: []\n    };\n    this.batch = batch;\n    this.schedule(async () => {\n      batch.completed = true;\n      if (batch.directories.length === 0) return;\n      // Collect all the results for each of the directories. If any error\n      // occurs, send the results back to the loaders.\n      let values;\n      try {\n        values = await this.load(batch.directories);\n      } catch (err) {\n        // Reject all the callbacks.\n        for (const {\n          reject\n        } of batch.callbacks) {\n          reject(err);\n        }\n        return;\n      }\n      // Loop over all the callbacks and send them their results.\n      for (let i = 0; i < batch.callbacks.length; i++) {\n        const value = values[i];\n        if (value instanceof Error) {\n          batch.callbacks[i].reject(value);\n        } else {\n          batch.callbacks[i].resolve(value);\n        }\n      }\n    });\n    return batch;\n  }\n  async load(directories) {\n    // Make a unique array of directories. This is what lets us de-duplicate\n    // loads for the same directory.\n    const unique = [...new Set(directories)];\n    const results = await Promise.all(unique.map(async directory => {\n      let files;\n      let error;\n      try {\n        files = await this.reader.read(directory);\n      } catch (err) {\n        if (err instanceof Error) error = err;\n      }\n      return {\n        directory,\n        files,\n        error\n      };\n    }));\n    return directories.map(directory => {\n      const found = results.find(result => result.directory === directory);\n      if (!found) return [];\n      if (found.files) return found.files;\n      if (found.error) return found.error;\n      return [];\n    });\n  }\n  async read(dir) {\n    // Get or create a new file reading batch.\n    const batch = this.getOrCreateBatch();\n    // Push this directory into the batch to resolve.\n    batch.directories.push(dir);\n    // Push the promise handles into the batch (under the same index) so it can\n    // be resolved later when it's scheduled.\n    const promise = new Promise((resolve, reject) => {\n      batch.callbacks.push({\n        resolve,\n        reject\n      });\n    });\n    return promise;\n  }\n}","map":{"version":3,"names":["BatchedFileReader","constructor","reader","schedule","callback","schedulePromise","Promise","resolve","then","process","nextTick","getOrCreateBatch","batch","completed","directories","callbacks","length","values","load","err","reject","i","value","Error","unique","Set","results","all","map","directory","files","error","read","found","find","result","dir","push","promise"],"sources":["../../../../../../../src/server/future/route-matcher-providers/dev/helpers/file-reader/batched-file-reader.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}