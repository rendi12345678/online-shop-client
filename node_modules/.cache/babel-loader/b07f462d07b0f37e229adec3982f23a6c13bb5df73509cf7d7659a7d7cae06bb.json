{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"Batcher\", {\n  enumerable: true,\n  get: function () {\n    return Batcher;\n  }\n});\nconst _detachedpromise = require(\"./detached-promise\");\nclass Batcher {\n  constructor(cacheKeyFn, schedulerFn = fn => fn()) {\n    this.cacheKeyFn = cacheKeyFn;\n    this.schedulerFn = schedulerFn;\n    this.pending = new Map();\n  }\n  static create(options) {\n    return new Batcher(options == null ? void 0 : options.cacheKeyFn, options == null ? void 0 : options.schedulerFn);\n  }\n  /**\n  * Wraps a function in a promise that will be resolved or rejected only once\n  * for a given key. This will allow multiple calls to the function to be\n  * made, but only one will be executed at a time. The result of the first\n  * call will be returned to all callers.\n  *\n  * @param key the key to use for the cache\n  * @param fn the function to wrap\n  * @returns a promise that resolves to the result of the function\n  */\n  async batch(key, fn) {\n    const cacheKey = this.cacheKeyFn ? await this.cacheKeyFn(key) : key;\n    if (cacheKey === null) {\n      return fn(cacheKey, Promise.resolve);\n    }\n    const pending = this.pending.get(cacheKey);\n    if (pending) return pending;\n    const {\n      promise,\n      resolve,\n      reject\n    } = new _detachedpromise.DetachedPromise();\n    this.pending.set(cacheKey, promise);\n    this.schedulerFn(async () => {\n      try {\n        const result = await fn(cacheKey, resolve);\n        // Resolving a promise multiple times is a no-op, so we can safely\n        // resolve all pending promises with the same result.\n        resolve(result);\n      } catch (err) {\n        reject(err);\n      } finally {\n        this.pending.delete(cacheKey);\n      }\n    });\n    return promise;\n  }\n}","map":{"version":3,"names":["Batcher","constructor","cacheKeyFn","schedulerFn","fn","pending","Map","create","options","batch","key","cacheKey","Promise","resolve","get","promise","reject","_detachedpromise","DetachedPromise","set","result","err","delete"],"sources":["../../src/lib/batcher.ts"],"sourcesContent":[null],"mappings":";;;;;+BAsBa;;;WAAAA,OAAA;;;iCApBmB;AAoBzB,MAAMA,OAAA;EAGXC,YACmBC,UAAA,EAMAC,WAAA,GAAkCC,EAAA,IAAOA,EAAA,EAAI,EAC9D;sBAPiBF,UAAA;uBAMAC,WAAA;SATFE,OAAA,GAAU,IAAIC,GAAA;EAU5B;EAcH,OAAcC,OACZC,OAA8B,EACZ;IAClB,OAAO,IAAIR,OAAA,CAAiBQ,OAAA,oBAAAA,OAAA,CAASN,UAAU,EAAEM,OAAA,oBAAAA,OAAA,CAASL,WAAW;EACvE;EAEA;;;;;;;;;;EAUA,MAAaM,MAAMC,GAAM,EAAEN,EAAgB,EAAc;IACvD,MAAMO,QAAA,GAAY,IAAI,CAACT,UAAU,GAAG,MAAM,IAAI,CAACA,UAAU,CAACQ,GAAA,IAAOA,GAAA;IACjE,IAAIC,QAAA,KAAa,MAAM;MACrB,OAAOP,EAAA,CAAGO,QAAA,EAAUC,OAAA,CAAQC,OAAO;IACrC;IAEA,MAAMR,OAAA,GAAU,IAAI,CAACA,OAAO,CAACS,GAAG,CAACH,QAAA;IACjC,IAAIN,OAAA,EAAS,OAAOA,OAAA;IAEpB,MAAM;MAAEU,OAAO;MAAEF,OAAO;MAAEG;IAAM,CAAE,GAAG,IAAIC,gBAAA,CAAAC,eAAe;IACxD,IAAI,CAACb,OAAO,CAACc,GAAG,CAACR,QAAA,EAAUI,OAAA;IAE3B,IAAI,CAACZ,WAAW,CAAC;MACf,IAAI;QACF,MAAMiB,MAAA,GAAS,MAAMhB,EAAA,CAAGO,QAAA,EAAUE,OAAA;QAElC;QACA;QACAA,OAAA,CAAQO,MAAA;MACV,EAAE,OAAOC,GAAA,EAAK;QACZL,MAAA,CAAOK,GAAA;MACT,UAAU;QACR,IAAI,CAAChB,OAAO,CAACiB,MAAM,CAACX,QAAA;MACtB;IACF;IAEA,OAAOI,OAAA;EACT;AACF"},"metadata":{},"sourceType":"script","externalDependencies":[]}