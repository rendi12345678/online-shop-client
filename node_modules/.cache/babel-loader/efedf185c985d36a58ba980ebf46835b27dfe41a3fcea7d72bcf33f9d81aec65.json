{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"default\", {\n  enumerable: true,\n  get: function () {\n    return FileSystemCache;\n  }\n});\nconst _lrucache = /*#__PURE__*/_interop_require_default(require(\"next/dist/compiled/lru-cache\"));\nconst _path = /*#__PURE__*/_interop_require_default(require(\"../../../shared/lib/isomorphic/path\"));\nconst _constants = require(\"../../../lib/constants\");\nfunction _interop_require_default(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nlet memoryCache;\nlet tagsManifest;\nclass FileSystemCache {\n  constructor(ctx) {\n    this.fs = ctx.fs;\n    this.flushToDisk = ctx.flushToDisk;\n    this.serverDistDir = ctx.serverDistDir;\n    this.appDir = !!ctx._appDir;\n    this.revalidatedTags = ctx.revalidatedTags;\n    if (ctx.maxMemoryCacheSize && !memoryCache) {\n      memoryCache = new _lrucache.default({\n        max: ctx.maxMemoryCacheSize,\n        length({\n          value\n        }) {\n          var _JSON_stringify;\n          if (!value) {\n            return 25;\n          } else if (value.kind === \"REDIRECT\") {\n            return JSON.stringify(value.props).length;\n          } else if (value.kind === \"IMAGE\") {\n            throw new Error(\"invariant image should not be incremental-cache\");\n          } else if (value.kind === \"FETCH\") {\n            return JSON.stringify(value.data || \"\").length;\n          } else if (value.kind === \"ROUTE\") {\n            return value.body.length;\n          }\n          // rough estimate of size of cache value\n          return value.html.length + (((_JSON_stringify = JSON.stringify(value.pageData)) == null ? void 0 : _JSON_stringify.length) || 0);\n        }\n      });\n    }\n    if (this.serverDistDir && this.fs) {\n      this.tagsManifestPath = _path.default.join(this.serverDistDir, \"..\", \"cache\", \"fetch-cache\", \"tags-manifest.json\");\n      this.loadTagsManifest();\n    }\n  }\n  loadTagsManifest() {\n    if (!this.tagsManifestPath || !this.fs || tagsManifest) return;\n    try {\n      tagsManifest = JSON.parse(this.fs.readFileSync(this.tagsManifestPath, \"utf8\"));\n    } catch (err) {\n      tagsManifest = {\n        version: 1,\n        items: {}\n      };\n    }\n  }\n  async revalidateTag(tag) {\n    // we need to ensure the tagsManifest is refreshed\n    // since separate workers can be updating it at the same\n    // time and we can't flush out of sync data\n    this.loadTagsManifest();\n    if (!tagsManifest || !this.tagsManifestPath) {\n      return;\n    }\n    const data = tagsManifest.items[tag] || {};\n    data.revalidatedAt = Date.now();\n    tagsManifest.items[tag] = data;\n    try {\n      await this.fs.mkdir(_path.default.dirname(this.tagsManifestPath));\n      await this.fs.writeFile(this.tagsManifestPath, JSON.stringify(tagsManifest || {}));\n    } catch (err) {\n      console.warn(\"Failed to update tags manifest.\", err);\n    }\n  }\n  async get(key, {\n    tags,\n    softTags,\n    fetchCache\n  } = {}) {\n    var _data_value, _data_value1;\n    let data = memoryCache == null ? void 0 : memoryCache.get(key);\n    // let's check the disk for seed data\n    if (!data && process.env.NEXT_RUNTIME !== \"edge\") {\n      try {\n        const {\n          filePath\n        } = await this.getFsPath({\n          pathname: `${key}.body`,\n          appDir: true\n        });\n        const fileData = await this.fs.readFile(filePath);\n        const {\n          mtime\n        } = await this.fs.stat(filePath);\n        const meta = JSON.parse(await this.fs.readFile(filePath.replace(/\\.body$/, \".meta\"), \"utf8\"));\n        const cacheEntry = {\n          lastModified: mtime.getTime(),\n          value: {\n            kind: \"ROUTE\",\n            body: fileData,\n            headers: meta.headers,\n            status: meta.status\n          }\n        };\n        return cacheEntry;\n      } catch (_) {\n        // no .meta data for the related key\n      }\n      try {\n        const {\n          filePath,\n          isAppPath\n        } = await this.getFsPath({\n          pathname: fetchCache ? key : `${key}.html`,\n          fetchCache\n        });\n        const fileData = await this.fs.readFile(filePath, \"utf8\");\n        const {\n          mtime\n        } = await this.fs.stat(filePath);\n        if (fetchCache) {\n          var _data_value2;\n          const lastModified = mtime.getTime();\n          const parsedData = JSON.parse(fileData);\n          data = {\n            lastModified,\n            value: parsedData\n          };\n          if (((_data_value2 = data.value) == null ? void 0 : _data_value2.kind) === \"FETCH\") {\n            var _data_value_data, _data_value3;\n            const storedTags = (_data_value3 = data.value) == null ? void 0 : (_data_value_data = _data_value3.data) == null ? void 0 : _data_value_data.tags;\n            // update stored tags if a new one is being added\n            // TODO: remove this when we can send the tags\n            // via header on GET same as SET\n            if (!(tags == null ? void 0 : tags.every(tag => storedTags == null ? void 0 : storedTags.includes(tag)))) {\n              await this.set(key, data.value, {\n                tags\n              });\n            }\n          }\n        } else {\n          const pageData = isAppPath ? await this.fs.readFile((await this.getFsPath({\n            pathname: `${key}.rsc`,\n            appDir: true\n          })).filePath, \"utf8\") : JSON.parse(await this.fs.readFile((await this.getFsPath({\n            pathname: `${key}.json`,\n            appDir: false\n          })).filePath, \"utf8\"));\n          let meta;\n          if (isAppPath) {\n            try {\n              meta = JSON.parse(await this.fs.readFile(filePath.replace(/\\.html$/, \".meta\"), \"utf8\"));\n            } catch {}\n          }\n          data = {\n            lastModified: mtime.getTime(),\n            value: {\n              kind: \"PAGE\",\n              html: fileData,\n              pageData,\n              postponed: meta == null ? void 0 : meta.postponed,\n              headers: meta == null ? void 0 : meta.headers,\n              status: meta == null ? void 0 : meta.status\n            }\n          };\n        }\n        if (data) {\n          memoryCache == null ? void 0 : memoryCache.set(key, data);\n        }\n      } catch (_) {\n        // unable to get data from disk\n      }\n    }\n    if ((data == null ? void 0 : (_data_value = data.value) == null ? void 0 : _data_value.kind) === \"PAGE\") {\n      var _data_value_headers;\n      let cacheTags;\n      const tagsHeader = (_data_value_headers = data.value.headers) == null ? void 0 : _data_value_headers[_constants.NEXT_CACHE_TAGS_HEADER];\n      if (typeof tagsHeader === \"string\") {\n        cacheTags = tagsHeader.split(\",\");\n      }\n      if (cacheTags == null ? void 0 : cacheTags.length) {\n        this.loadTagsManifest();\n        const isStale = cacheTags.some(tag => {\n          var _tagsManifest_items_tag;\n          return (tagsManifest == null ? void 0 : (_tagsManifest_items_tag = tagsManifest.items[tag]) == null ? void 0 : _tagsManifest_items_tag.revalidatedAt) && (tagsManifest == null ? void 0 : tagsManifest.items[tag].revalidatedAt) >= ((data == null ? void 0 : data.lastModified) || Date.now());\n        });\n        // we trigger a blocking validation if an ISR page\n        // had a tag revalidated, if we want to be a background\n        // revalidation instead we return data.lastModified = -1\n        if (isStale) {\n          data = undefined;\n        }\n      }\n    }\n    if (data && (data == null ? void 0 : (_data_value1 = data.value) == null ? void 0 : _data_value1.kind) === \"FETCH\") {\n      this.loadTagsManifest();\n      const combinedTags = [...(tags || []), ...(softTags || [])];\n      const wasRevalidated = combinedTags.some(tag => {\n        var _tagsManifest_items_tag;\n        if (this.revalidatedTags.includes(tag)) {\n          return true;\n        }\n        return (tagsManifest == null ? void 0 : (_tagsManifest_items_tag = tagsManifest.items[tag]) == null ? void 0 : _tagsManifest_items_tag.revalidatedAt) && (tagsManifest == null ? void 0 : tagsManifest.items[tag].revalidatedAt) >= ((data == null ? void 0 : data.lastModified) || Date.now());\n      });\n      // When revalidate tag is called we don't return\n      // stale data so it's updated right away\n      if (wasRevalidated) {\n        data = undefined;\n      }\n    }\n    return data ?? null;\n  }\n  async set(key, data, ctx) {\n    memoryCache == null ? void 0 : memoryCache.set(key, {\n      value: data,\n      lastModified: Date.now()\n    });\n    if (!this.flushToDisk) return;\n    if ((data == null ? void 0 : data.kind) === \"ROUTE\") {\n      const {\n        filePath\n      } = await this.getFsPath({\n        pathname: `${key}.body`,\n        appDir: true\n      });\n      await this.fs.mkdir(_path.default.dirname(filePath));\n      await this.fs.writeFile(filePath, data.body);\n      const meta = {\n        headers: data.headers,\n        status: data.status,\n        postponed: undefined\n      };\n      await this.fs.writeFile(filePath.replace(/\\.body$/, \".meta\"), JSON.stringify(meta, null, 2));\n      return;\n    }\n    if ((data == null ? void 0 : data.kind) === \"PAGE\") {\n      const isAppPath = typeof data.pageData === \"string\";\n      const {\n        filePath: htmlPath\n      } = await this.getFsPath({\n        pathname: `${key}.html`,\n        appDir: isAppPath\n      });\n      await this.fs.mkdir(_path.default.dirname(htmlPath));\n      await this.fs.writeFile(htmlPath, data.html);\n      await this.fs.writeFile((await this.getFsPath({\n        pathname: `${key}.${isAppPath ? \"rsc\" : \"json\"}`,\n        appDir: isAppPath\n      })).filePath, isAppPath ? data.pageData : JSON.stringify(data.pageData));\n      if (data.headers || data.status) {\n        const meta = {\n          headers: data.headers,\n          status: data.status,\n          postponed: data.postponed\n        };\n        await this.fs.writeFile(htmlPath.replace(/\\.html$/, \".meta\"), JSON.stringify(meta));\n      }\n    } else if ((data == null ? void 0 : data.kind) === \"FETCH\") {\n      const {\n        filePath\n      } = await this.getFsPath({\n        pathname: key,\n        fetchCache: true\n      });\n      await this.fs.mkdir(_path.default.dirname(filePath));\n      await this.fs.writeFile(filePath, JSON.stringify({\n        ...data,\n        tags: ctx.tags\n      }));\n    }\n  }\n  async getFsPath({\n    pathname,\n    appDir,\n    fetchCache\n  }) {\n    if (fetchCache) {\n      // we store in .next/cache/fetch-cache so it can be persisted\n      // across deploys\n      return {\n        filePath: _path.default.join(this.serverDistDir, \"..\", \"cache\", \"fetch-cache\", pathname),\n        isAppPath: false\n      };\n    }\n    let isAppPath = false;\n    let filePath = _path.default.join(this.serverDistDir, \"pages\", pathname);\n    if (!this.appDir || appDir === false) return {\n      filePath,\n      isAppPath\n    };\n    try {\n      await this.fs.readFile(filePath);\n      return {\n        filePath,\n        isAppPath\n      };\n    } catch (err) {\n      return {\n        filePath: _path.default.join(this.serverDistDir, \"app\", pathname),\n        isAppPath: true\n      };\n    }\n  }\n}","map":{"version":3,"names":["FileSystemCache","memoryCache","tagsManifest","constructor","ctx","fs","flushToDisk","serverDistDir","appDir","_appDir","revalidatedTags","maxMemoryCacheSize","_lrucache","default","max","length","value","_JSON_stringify","kind","JSON","stringify","props","Error","data","body","html","pageData","tagsManifestPath","_path","join","loadTagsManifest","parse","readFileSync","err","version","items","revalidateTag","tag","revalidatedAt","Date","now","mkdir","dirname","writeFile","console","warn","get","key","tags","softTags","fetchCache","_data_value","_data_value1","process","env","NEXT_RUNTIME","filePath","getFsPath","pathname","fileData","readFile","mtime","stat","meta","replace","cacheEntry","lastModified","getTime","headers","status","_","isAppPath","_data_value2","parsedData","_data_value_data","_data_value3","storedTags","every","includes","set","postponed","_data_value_headers","cacheTags","tagsHeader","_constants","NEXT_CACHE_TAGS_HEADER","split","isStale","some","_tagsManifest_items_tag","undefined","combinedTags","wasRevalidated","htmlPath"],"sources":["../../../../src/server/lib/incremental-cache/file-system-cache.ts"],"sourcesContent":[null],"mappings":";;;;;+BAwBA;;;WAAqBA,eAAA;;;gEAnBA;4DACJ;2BACsB;;;;;;AAcvC,IAAIC,WAAA;AACJ,IAAIC,YAAA;AAEW,MAAMF,eAAA;EAQnBG,YAAYC,GAA2B,EAAE;IACvC,IAAI,CAACC,EAAE,GAAGD,GAAA,CAAIC,EAAE;IAChB,IAAI,CAACC,WAAW,GAAGF,GAAA,CAAIE,WAAW;IAClC,IAAI,CAACC,aAAa,GAAGH,GAAA,CAAIG,aAAa;IACtC,IAAI,CAACC,MAAM,GAAG,CAAC,CAACJ,GAAA,CAAIK,OAAO;IAC3B,IAAI,CAACC,eAAe,GAAGN,GAAA,CAAIM,eAAe;IAE1C,IAAIN,GAAA,CAAIO,kBAAkB,IAAI,CAACV,WAAA,EAAa;MAC1CA,WAAA,GAAc,IAAIW,SAAA,CAAAC,OAAQ,CAAC;QACzBC,GAAA,EAAKV,GAAA,CAAIO,kBAAkB;QAC3BI,OAAO;UAAEC;QAAK,CAAE;cAcSC,eAAA;UAbvB,IAAI,CAACD,KAAA,EAAO;YACV,OAAO;UACT,OAAO,IAAIA,KAAA,CAAME,IAAI,KAAK,YAAY;YACpC,OAAOC,IAAA,CAAKC,SAAS,CAACJ,KAAA,CAAMK,KAAK,EAAEN,MAAM;UAC3C,OAAO,IAAIC,KAAA,CAAME,IAAI,KAAK,SAAS;YACjC,MAAM,IAAII,KAAA,CAAM;UAClB,OAAO,IAAIN,KAAA,CAAME,IAAI,KAAK,SAAS;YACjC,OAAOC,IAAA,CAAKC,SAAS,CAACJ,KAAA,CAAMO,IAAI,IAAI,IAAIR,MAAM;UAChD,OAAO,IAAIC,KAAA,CAAME,IAAI,KAAK,SAAS;YACjC,OAAOF,KAAA,CAAMQ,IAAI,CAACT,MAAM;UAC1B;UACA;UACA,OACEC,KAAA,CAAMS,IAAI,CAACV,MAAM,IAAI,EAAAE,eAAA,GAAAE,IAAA,CAAKC,SAAS,CAACJ,KAAA,CAAMU,QAAQ,sBAA7BT,eAAA,CAAgCF,MAAM,KAAI;QAEnE;MACF;IACF;IACA,IAAI,IAAI,CAACR,aAAa,IAAI,IAAI,CAACF,EAAE,EAAE;MACjC,IAAI,CAACsB,gBAAgB,GAAGC,KAAA,CAAAf,OAAI,CAACgB,IAAI,CAC/B,IAAI,CAACtB,aAAa,EAClB,MACA,SACA,eACA;MAEF,IAAI,CAACuB,gBAAgB;IACvB;EACF;EAEQA,iBAAA,EAAmB;IACzB,IAAI,CAAC,IAAI,CAACH,gBAAgB,IAAI,CAAC,IAAI,CAACtB,EAAE,IAAIH,YAAA,EAAc;IACxD,IAAI;MACFA,YAAA,GAAeiB,IAAA,CAAKY,KAAK,CACvB,IAAI,CAAC1B,EAAE,CAAC2B,YAAY,CAAC,IAAI,CAACL,gBAAgB,EAAE;IAEhD,EAAE,OAAOM,GAAA,EAAU;MACjB/B,YAAA,GAAe;QAAEgC,OAAA,EAAS;QAAGC,KAAA,EAAO,CAAC;MAAE;IACzC;EACF;EAEA,MAAaC,cAAcC,GAAW,EAAE;IACtC;IACA;IACA;IACA,IAAI,CAACP,gBAAgB;IACrB,IAAI,CAAC5B,YAAA,IAAgB,CAAC,IAAI,CAACyB,gBAAgB,EAAE;MAC3C;IACF;IAEA,MAAMJ,IAAA,GAAOrB,YAAA,CAAaiC,KAAK,CAACE,GAAA,CAAI,IAAI,CAAC;IACzCd,IAAA,CAAKe,aAAa,GAAGC,IAAA,CAAKC,GAAG;IAC7BtC,YAAA,CAAaiC,KAAK,CAACE,GAAA,CAAI,GAAGd,IAAA;IAE1B,IAAI;MACF,MAAM,IAAI,CAAClB,EAAE,CAACoC,KAAK,CAACb,KAAA,CAAAf,OAAI,CAAC6B,OAAO,CAAC,IAAI,CAACf,gBAAgB;MACtD,MAAM,IAAI,CAACtB,EAAE,CAACsC,SAAS,CACrB,IAAI,CAAChB,gBAAgB,EACrBR,IAAA,CAAKC,SAAS,CAAClB,YAAA,IAAgB,CAAC;IAEpC,EAAE,OAAO+B,GAAA,EAAU;MACjBW,OAAA,CAAQC,IAAI,CAAC,mCAAmCZ,GAAA;IAClD;EACF;EAEA,MAAaa,IACXC,GAAW,EACX;IACEC,IAAI;IACJC,QAAQ;IACRC;EAAU,CAKX,GAAG,CAAC,CAAC,EACN;QAkHIC,WAAA,EA4BQC,YAAA;IA7IZ,IAAI7B,IAAA,GAAOtB,WAAA,oBAAAA,WAAA,CAAa6C,GAAG,CAACC,GAAA;IAE5B;IACA,IAAI,CAACxB,IAAA,IAAQ8B,OAAA,CAAQC,GAAG,CAACC,YAAY,KAAK,QAAQ;MAChD,IAAI;QACF,MAAM;UAAEC;QAAQ,CAAE,GAAG,MAAM,IAAI,CAACC,SAAS,CAAC;UACxCC,QAAA,EAAW,GAAEX,GAAI,OAAM;UACvBvC,MAAA,EAAQ;QACV;QACA,MAAMmD,QAAA,GAAW,MAAM,IAAI,CAACtD,EAAE,CAACuD,QAAQ,CAACJ,QAAA;QACxC,MAAM;UAAEK;QAAK,CAAE,GAAG,MAAM,IAAI,CAACxD,EAAE,CAACyD,IAAI,CAACN,QAAA;QAErC,MAAMO,IAAA,GAAO5C,IAAA,CAAKY,KAAK,CACrB,MAAM,IAAI,CAAC1B,EAAE,CAACuD,QAAQ,CAACJ,QAAA,CAASQ,OAAO,CAAC,WAAW,UAAU;QAG/D,MAAMC,UAAA,GAAgC;UACpCC,YAAA,EAAcL,KAAA,CAAMM,OAAO;UAC3BnD,KAAA,EAAO;YACLE,IAAA,EAAM;YACNM,IAAA,EAAMmC,QAAA;YACNS,OAAA,EAASL,IAAA,CAAKK,OAAO;YACrBC,MAAA,EAAQN,IAAA,CAAKM;UACf;QACF;QACA,OAAOJ,UAAA;MACT,EAAE,OAAOK,CAAA,EAAG;QACV;MAAA;MAGF,IAAI;QACF,MAAM;UAAEd,QAAQ;UAAEe;QAAS,CAAE,GAAG,MAAM,IAAI,CAACd,SAAS,CAAC;UACnDC,QAAA,EAAUR,UAAA,GAAaH,GAAA,GAAO,GAAEA,GAAI,OAAM;UAC1CG;QACF;QACA,MAAMS,QAAA,GAAW,MAAM,IAAI,CAACtD,EAAE,CAACuD,QAAQ,CAACJ,QAAA,EAAU;QAClD,MAAM;UAAEK;QAAK,CAAE,GAAG,MAAM,IAAI,CAACxD,EAAE,CAACyD,IAAI,CAACN,QAAA;QAErC,IAAIN,UAAA,EAAY;cAQVsB,YAAA;UAPJ,MAAMN,YAAA,GAAeL,KAAA,CAAMM,OAAO;UAClC,MAAMM,UAAA,GAA+BtD,IAAA,CAAKY,KAAK,CAAC4B,QAAA;UAChDpC,IAAA,GAAO;YACL2C,YAAA;YACAlD,KAAA,EAAOyD;UACT;UAEA,IAAI,EAAAD,YAAA,GAAAjD,IAAA,CAAKP,KAAK,qBAAVwD,YAAA,CAAYtD,IAAI,MAAK,SAAS;gBACbwD,gBAAA,EAAAC,YAAA;YAAnB,MAAMC,UAAA,IAAaD,YAAA,GAAApD,IAAA,CAAKP,KAAK,sBAAV0D,gBAAA,GAAAC,YAAA,CAAYpD,IAAI,qBAAhBmD,gBAAA,CAAkB1B,IAAI;YAEzC;YACA;YACA;YACA,IAAI,EAACA,IAAA,oBAAAA,IAAA,CAAM6B,KAAK,CAAExC,GAAA,IAAQuC,UAAA,oBAAAA,UAAA,CAAYE,QAAQ,CAACzC,GAAA,KAAO;cACpD,MAAM,IAAI,CAAC0C,GAAG,CAAChC,GAAA,EAAKxB,IAAA,CAAKP,KAAK,EAAE;gBAAEgC;cAAK;YACzC;UACF;QACF,OAAO;UACL,MAAMtB,QAAA,GAAW6C,SAAA,GACb,MAAM,IAAI,CAAClE,EAAE,CAACuD,QAAQ,CACpB,CACE,MAAM,IAAI,CAACH,SAAS,CAAC;YACnBC,QAAA,EAAW,GAAEX,GAAI,MAAK;YACtBvC,MAAA,EAAQ;UACV,EAAC,EACDgD,QAAQ,EACV,UAEFrC,IAAA,CAAKY,KAAK,CACR,MAAM,IAAI,CAAC1B,EAAE,CAACuD,QAAQ,CACpB,CACE,MAAM,IAAI,CAACH,SAAS,CAAC;YACnBC,QAAA,EAAW,GAAEX,GAAI,OAAM;YACvBvC,MAAA,EAAQ;UACV,EAAC,EACDgD,QAAQ,EACV;UAIR,IAAIO,IAAA;UAEJ,IAAIQ,SAAA,EAAW;YACb,IAAI;cACFR,IAAA,GAAO5C,IAAA,CAAKY,KAAK,CACf,MAAM,IAAI,CAAC1B,EAAE,CAACuD,QAAQ,CACpBJ,QAAA,CAASQ,OAAO,CAAC,WAAW,UAC5B;YAGN,EAAE,MAAM,CAAC;UACX;UAEAzC,IAAA,GAAO;YACL2C,YAAA,EAAcL,KAAA,CAAMM,OAAO;YAC3BnD,KAAA,EAAO;cACLE,IAAA,EAAM;cACNO,IAAA,EAAMkC,QAAA;cACNjC,QAAA;cACAsD,SAAS,EAAEjB,IAAA,oBAAAA,IAAA,CAAMiB,SAAS;cAC1BZ,OAAO,EAAEL,IAAA,oBAAAA,IAAA,CAAMK,OAAO;cACtBC,MAAM,EAAEN,IAAA,oBAAAA,IAAA,CAAMM;YAChB;UACF;QACF;QAEA,IAAI9C,IAAA,EAAM;UACRtB,WAAA,oBAAAA,WAAA,CAAa8E,GAAG,CAAChC,GAAA,EAAKxB,IAAA;QACxB;MACF,EAAE,OAAO+C,CAAA,EAAG;QACV;MAAA;IAEJ;IAEA,IAAI,CAAA/C,IAAA,qBAAA4B,WAAA,GAAA5B,IAAA,CAAMP,KAAK,qBAAXmC,WAAA,CAAajC,IAAI,MAAK,QAAQ;UAEb+D,mBAAA;MADnB,IAAIC,SAAA;MACJ,MAAMC,UAAA,IAAaF,mBAAA,GAAA1D,IAAA,CAAKP,KAAK,CAACoD,OAAO,qBAAlBa,mBAAoB,CAACG,UAAA,CAAAC,sBAAsB,CAAC;MAE/D,IAAI,OAAOF,UAAA,KAAe,UAAU;QAClCD,SAAA,GAAYC,UAAA,CAAWG,KAAK,CAAC;MAC/B;MAEA,IAAIJ,SAAA,oBAAAA,SAAA,CAAWnE,MAAM,EAAE;QACrB,IAAI,CAACe,gBAAgB;QAErB,MAAMyD,OAAA,GAAUL,SAAA,CAAUM,IAAI,CAAEnD,GAAA;cAE5BoD,uBAAA;UADF,OACE,CAAAvF,YAAA,qBAAAuF,uBAAA,GAAAvF,YAAA,CAAciC,KAAK,CAACE,GAAA,CAAI,qBAAxBoD,uBAAA,CAA0BnD,aAAa,KACvC,CAAApC,YAAA,oBAAAA,YAAA,CAAciC,KAAK,CAACE,GAAA,CAAI,CAACC,aAAa,MACnC,CAAAf,IAAA,oBAAAA,IAAA,CAAM2C,YAAY,KAAI3B,IAAA,CAAKC,GAAG,EAAC;QAEtC;QAEA;QACA;QACA;QACA,IAAI+C,OAAA,EAAS;UACXhE,IAAA,GAAOmE,SAAA;QACT;MACF;IACF;IAEA,IAAInE,IAAA,IAAQ,CAAAA,IAAA,qBAAA6B,YAAA,GAAA7B,IAAA,CAAMP,KAAK,qBAAXoC,YAAA,CAAalC,IAAI,MAAK,SAAS;MACzC,IAAI,CAACY,gBAAgB;MAErB,MAAM6D,YAAA,GAAe,C,IAAK3C,IAAA,IAAQ,EAAE,G,IAAOC,QAAA,IAAY,EAAE,EAAE;MAE3D,MAAM2C,cAAA,GAAiBD,YAAA,CAAaH,IAAI,CAAEnD,GAAA;YAMtCoD,uBAAA;QALF,IAAI,IAAI,CAAC/E,eAAe,CAACoE,QAAQ,CAACzC,GAAA,GAAM;UACtC,OAAO;QACT;QAEA,OACE,CAAAnC,YAAA,qBAAAuF,uBAAA,GAAAvF,YAAA,CAAciC,KAAK,CAACE,GAAA,CAAI,qBAAxBoD,uBAAA,CAA0BnD,aAAa,KACvC,CAAApC,YAAA,oBAAAA,YAAA,CAAciC,KAAK,CAACE,GAAA,CAAI,CAACC,aAAa,MACnC,CAAAf,IAAA,oBAAAA,IAAA,CAAM2C,YAAY,KAAI3B,IAAA,CAAKC,GAAG,EAAC;MAEtC;MACA;MACA;MACA,IAAIoD,cAAA,EAAgB;QAClBrE,IAAA,GAAOmE,SAAA;MACT;IACF;IAEA,OAAOnE,IAAA,IAAQ;EACjB;EAEA,MAAawD,IACXhC,GAAW,EACXxB,IAAgC,EAChCnB,GAEC,EACD;IACAH,WAAA,oBAAAA,WAAA,CAAa8E,GAAG,CAAChC,GAAA,EAAK;MACpB/B,KAAA,EAAOO,IAAA;MACP2C,YAAA,EAAc3B,IAAA,CAAKC,GAAG;IACxB;IACA,IAAI,CAAC,IAAI,CAAClC,WAAW,EAAE;IAEvB,IAAI,CAAAiB,IAAA,oBAAAA,IAAA,CAAML,IAAI,MAAK,SAAS;MAC1B,MAAM;QAAEsC;MAAQ,CAAE,GAAG,MAAM,IAAI,CAACC,SAAS,CAAC;QACxCC,QAAA,EAAW,GAAEX,GAAI,OAAM;QACvBvC,MAAA,EAAQ;MACV;MACA,MAAM,IAAI,CAACH,EAAE,CAACoC,KAAK,CAACb,KAAA,CAAAf,OAAI,CAAC6B,OAAO,CAACc,QAAA;MACjC,MAAM,IAAI,CAACnD,EAAE,CAACsC,SAAS,CAACa,QAAA,EAAUjC,IAAA,CAAKC,IAAI;MAE3C,MAAMuC,IAAA,GAAsB;QAC1BK,OAAA,EAAS7C,IAAA,CAAK6C,OAAO;QACrBC,MAAA,EAAQ9C,IAAA,CAAK8C,MAAM;QACnBW,SAAA,EAAWU;MACb;MAEA,MAAM,IAAI,CAACrF,EAAE,CAACsC,SAAS,CACrBa,QAAA,CAASQ,OAAO,CAAC,WAAW,UAC5B7C,IAAA,CAAKC,SAAS,CAAC2C,IAAA,EAAM,MAAM;MAE7B;IACF;IAEA,IAAI,CAAAxC,IAAA,oBAAAA,IAAA,CAAML,IAAI,MAAK,QAAQ;MACzB,MAAMqD,SAAA,GAAY,OAAOhD,IAAA,CAAKG,QAAQ,KAAK;MAC3C,MAAM;QAAE8B,QAAA,EAAUqC;MAAQ,CAAE,GAAG,MAAM,IAAI,CAACpC,SAAS,CAAC;QAClDC,QAAA,EAAW,GAAEX,GAAI,OAAM;QACvBvC,MAAA,EAAQ+D;MACV;MACA,MAAM,IAAI,CAAClE,EAAE,CAACoC,KAAK,CAACb,KAAA,CAAAf,OAAI,CAAC6B,OAAO,CAACmD,QAAA;MACjC,MAAM,IAAI,CAACxF,EAAE,CAACsC,SAAS,CAACkD,QAAA,EAAUtE,IAAA,CAAKE,IAAI;MAE3C,MAAM,IAAI,CAACpB,EAAE,CAACsC,SAAS,CACrB,CACE,MAAM,IAAI,CAACc,SAAS,CAAC;QACnBC,QAAA,EAAW,GAAEX,GAAI,IAAGwB,SAAA,GAAY,QAAQ,MAAO,EAAC;QAChD/D,MAAA,EAAQ+D;MACV,EAAC,EACDf,QAAQ,EACVe,SAAA,GAAYhD,IAAA,CAAKG,QAAQ,GAAGP,IAAA,CAAKC,SAAS,CAACG,IAAA,CAAKG,QAAQ;MAG1D,IAAIH,IAAA,CAAK6C,OAAO,IAAI7C,IAAA,CAAK8C,MAAM,EAAE;QAC/B,MAAMN,IAAA,GAAsB;UAC1BK,OAAA,EAAS7C,IAAA,CAAK6C,OAAO;UACrBC,MAAA,EAAQ9C,IAAA,CAAK8C,MAAM;UACnBW,SAAA,EAAWzD,IAAA,CAAKyD;QAClB;QAEA,MAAM,IAAI,CAAC3E,EAAE,CAACsC,SAAS,CACrBkD,QAAA,CAAS7B,OAAO,CAAC,WAAW,UAC5B7C,IAAA,CAAKC,SAAS,CAAC2C,IAAA;MAEnB;IACF,OAAO,IAAI,CAAAxC,IAAA,oBAAAA,IAAA,CAAML,IAAI,MAAK,SAAS;MACjC,MAAM;QAAEsC;MAAQ,CAAE,GAAG,MAAM,IAAI,CAACC,SAAS,CAAC;QACxCC,QAAA,EAAUX,GAAA;QACVG,UAAA,EAAY;MACd;MACA,MAAM,IAAI,CAAC7C,EAAE,CAACoC,KAAK,CAACb,KAAA,CAAAf,OAAI,CAAC6B,OAAO,CAACc,QAAA;MACjC,MAAM,IAAI,CAACnD,EAAE,CAACsC,SAAS,CACrBa,QAAA,EACArC,IAAA,CAAKC,SAAS,CAAC;QACb,GAAGG,IAAI;QACPyB,IAAA,EAAM5C,GAAA,CAAI4C;MACZ;IAEJ;EACF;EAEA,MAAcS,UAAU;IACtBC,QAAQ;IACRlD,MAAM;IACN0C;EAAU,CAKX,EAGE;IACD,IAAIA,UAAA,EAAY;MACd;MACA;MACA,OAAO;QACLM,QAAA,EAAU5B,KAAA,CAAAf,OAAI,CAACgB,IAAI,CACjB,IAAI,CAACtB,aAAa,EAClB,MACA,SACA,eACAmD,QAAA;QAEFa,SAAA,EAAW;MACb;IACF;IACA,IAAIA,SAAA,GAAY;IAChB,IAAIf,QAAA,GAAW5B,KAAA,CAAAf,OAAI,CAACgB,IAAI,CAAC,IAAI,CAACtB,aAAa,EAAE,SAASmD,QAAA;IAEtD,IAAI,CAAC,IAAI,CAAClD,MAAM,IAAIA,MAAA,KAAW,OAC7B,OAAO;MACLgD,QAAA;MACAe;IACF;IACF,IAAI;MACF,MAAM,IAAI,CAAClE,EAAE,CAACuD,QAAQ,CAACJ,QAAA;MACvB,OAAO;QACLA,QAAA;QACAe;MACF;IACF,EAAE,OAAOtC,GAAA,EAAK;MACZ,OAAO;QACLuB,QAAA,EAAU5B,KAAA,CAAAf,OAAI,CAACgB,IAAI,CAAC,IAAI,CAACtB,aAAa,EAAE,OAAOmD,QAAA;QAC/Ca,SAAA,EAAW;MACb;IACF;EACF;AACF"},"metadata":{},"sourceType":"script","externalDependencies":[]}